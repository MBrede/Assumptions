% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Robustheit},
  pdfauthor={Max Brede und Johannes Andres},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{tikz}

\newenvironment{cols}[1][]{}{}

\newenvironment{col}[1]{\begin{minipage}{#1}\ignorespaces}{%
\end{minipage}
\ifhmode\unskip\fi
\aftergroup\useignorespacesandallpars}

\def\useignorespacesandallpars#1\ignorespaces\fi{%
#1\fi\ignorespacesandallpars}

\makeatletter
\def\ignorespacesandallpars{%
  \@ifnextchar\par
    {\expandafter\ignorespacesandallpars\@gobble}%
    {}%
}
\makeatother

\usetikzlibrary{arrows, arrows.meta, calc, positioning, quotes, shapes}
\tikzset{
    mynode/.style={draw,text width=1in,align=center},
    mylabel/.style={text width=7em}
}

\definecolor{White}{gray}{1}
\definecolor{Black}{gray}{0}
\definecolor{Gray}{gray}{0.5}
\definecolor{LightGray}{gray}{0.99}
\definecolor{DarkGray}{gray}{0.6}
\definecolor{LightBlue}{rgb}{0.9 0.9 1}
\definecolor{Blue}{rgb}{0.55 0.55 1}
\definecolor{DarkBlue}{rgb}{0.2 0.2 1}
\definecolor{Red}{rgb}{1 0 0}
\definecolor{DarkRed}{rgb}{0.7 0 0}
\definecolor{Green}{rgb}{0 0.8 0.2}


\usepackage{lscape}
\newcommand{\blandscape}{\begin{landscape}}
\newcommand{\elandscape}{\end{landscape}}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Robustheit}
\author{Max Brede und Johannes Andres}
\date{2021-11-26}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{vorwort}{%
\chapter{Vorwort}\label{vorwort}}

Dieses mit \texttt{bookdown} erstellte Dokument ist das Skript zum Seminar ``psyM9-1: Psychologische Forschungsmethoden. Projektseminar I'' und ``PSY\_B\_20\_e-1: Forschungsorientierte Vertiefung: Forschungsmethoden'' der CAU zu Kiel.

\hypertarget{lehrplan}{%
\chapter{Lehrplan}\label{lehrplan}}

\hypertarget{semesterplan}{%
\section{Semesterplan}\label{semesterplan}}

\scriptsize

\begin{longtable}[t]{>{\raggedright\arraybackslash}p{0.33in}>{\raggedright\arraybackslash}p{0.7in}>{\raggedright\arraybackslash}p{1in}>{\raggedright\arraybackslash}p{4in}}
\toprule
Sitzung & Datum & Sitzungstitel & Lernziele\\
\midrule
 &  &  & Die Studierenden…\\
1 & 2021-10-25 & Rste Codeschnipsel & können Funktionen in R definieren, deren Bestandteile nennen und diese benutzen.\\
 &  &  & wissen, was if-Statements sind und können diese in R einsetzen\\
2 & 2021-11-01 & Iterationen und Zufallszahlen & wissen, was for- und while-Schleifen sind und können diese in R einsetzen\\
 &  &  & können Werte von Zufallszahlen in R erzeugen\\
\addlinespace
3 & 2021-11-08 & Listen und Matrizen & wissen, wie eine „list“ in R aufgebaut ist und können diese benutzen\\
 &  &  & können Matrizen in R benutzen\\
4 & 2021-11-15 & Welche Iterationen? & kennen verschiedene Arten von Rs iterativen „functionals“ und können diese benutzen\\
 &  &  & können basales microbenchmarking einsetzen um Funktionsperformance zu evaluieren\\
5 & 2021-11-22 & Beispiele & haben erste Erfahrungen mit der Durchführung von Simulationsstudien in R\\
\addlinespace
6 & 2021-11-29 & Beispiele & \\
7 & 2021-12-06 & Psychopy I & können einfache Reaktionszeit- und Rating-Experimente in Psychopy erstellen\\
8 & 2021-12-13 & Psychopy II & können Ergebnisse von mit Psychopy und Pavlovia durchgeführten Studien in R einlesen und aufbereiten\\
9 & 2021-12-20 & Beispiele & haben erste Erfahrungen mit der Durchführung von Experimenten in Psychopy und Pavlovia\\
10 & 2022-01-10 & Puffer & \\
\addlinespace
11 & 2022-01-17 & Puffer & \\
12 & 2022-01-24 & Puffer & \\
13 & 2022-01-31 & Puffer & \\
\bottomrule
\end{longtable}

\normalsize

\hypertarget{part-programmieren-in-r}{%
\part{Programmieren in R}\label{part-programmieren-in-r}}

\hypertarget{funktionen}{%
\chapter{Funktionen}\label{funktionen}}

Wir kennen Funktionen ja schon aus den EDV-Veranstaltungen.

Zum Beispiel macht die \texttt{sum}-Funktion mit einem Vektor das, was der Name sagt:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{+} \DecValTok{2} \SpecialCharTok{+} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

Funktionen können wir auch selbst definieren. Eine Funktion, die uns begrüßt könnte zum Beispiel wie folgt aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_me }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{()\{}
  \FunctionTok{return}\NormalTok{(}\StringTok{\textquotesingle{}Hello! Nice to see you!\textquotesingle{}}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wenn wir jetzt die \texttt{greet\_me}-Funktion aufrufen, sehen wir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{greet\_me}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello! Nice to see you!"
\end{verbatim}

In der Funktionsdefinition können wir ein paar Teile wiederkennen.
Zum Einen ist da der \texttt{greet\_me\ \textless{}-}-Teil, den wir ja schon als Objektzuweisung kennen. Wir weisen also dem Ergebnis eines Ausdrucks den Namen \texttt{greet\_me} zu.

Funktions-\emph{Objekte} werden also genauso wie Datensätze und Vektoren als eine Kombination von Namen und zugehörigem Inhalt definiert.

Dabei erstellt die Funktion \texttt{function()} einen Objektinhalt, der aus \emph{body} und \emph{formals} besteht und in einem \emph{environment} definiert ist.

Der \emph{body} ist der Teil der Funktion, der definiert, was passieren soll und wird in R in geschweiften Klammern hinter der \texttt{function}-Funktion definiert
In unserem Beispiel besteht der body aus dem Aufruf, einen Text zurückzugeben:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{body}\NormalTok{(greet\_me)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## {
##     return("Hello! Nice to see you!")
## }
\end{verbatim}

Die \emph{formals} sind die Argumente, die bei der Ausführung des \emph{body}s genutzt werden sollen.

In unserem Beispiel haben wir noch keine Argumente berücksichtigt:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{formals}\NormalTok{(greet\_me)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

Wir könnten die Funktion aber neu definieren, so dass sie einen gegebenen Namen begrüßt. Dafür geben wir der \texttt{function}-Funktion ein Argument, das der Name des erwarteten Arguments sein soll:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{,name,}\StringTok{\textquotesingle{}! Nice to see you!\textquotesingle{}}\NormalTok{))}
\NormalTok{\}}

\FunctionTok{greet\_someone}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Marvin! Nice to see you!"
\end{verbatim}

Wenn wir uns jetzt nochmal die \texttt{formals} ausgeben lassen, sehen wir, dass ein Argument vorgesehen ist:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{formals}\NormalTok{(greet\_someone)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $name
\end{verbatim}

Der letzte Teil einer Funktionsdefinition ist das \emph{environment}. Damit ist der Namensraum gemeint, auf den die Funktion zugreifen kann:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{environment}\NormalTok{(greet\_someone)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <environment: R_GlobalEnv>
\end{verbatim}

In unserem Beispiel wurde die Funktion in der laufenden R-Session definiert (wie die allermeisten Funktionen, die wir dieses Semester nutzen werden). Der Output \texttt{R\_GlobalEnv} heißt also, dass die Funktion auf Objekte in der Haupt-R-Session zurückgreifen kann.

Praktisch heißt das, dass wir zum Beispiel Konstanten einmal außerhalb einer Funktion definieren können, die diese dann nutzen kann:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{10}

\NormalTok{greet\_someone\_n\_times }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name) \{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{, }
\NormalTok{                    name, }
                    \StringTok{\textquotesingle{}! Nice to see you!\textquotesingle{}}\NormalTok{), }
\NormalTok{             n))}
\NormalTok{\}}

\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
##  [3] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
##  [5] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
##  [7] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
##  [9] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
\end{verbatim}

Was das aber nicht heißt ist, dass die Funktion eine externe Variable ändern kann:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone\_n\_times }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name) \{}
  
\NormalTok{  n }\OtherTok{\textless{}{-}} \DecValTok{3}
  
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{, }
\NormalTok{                    name, }
                    \StringTok{\textquotesingle{}! Nice to see you!\textquotesingle{}}\NormalTok{), }
\NormalTok{             n))}
\NormalTok{\}}

\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
## [3] "Hello Marvin! Nice to see you!"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
\end{verbatim}

Das liegt daran, dass die Funktion beim Aufrufen eine Kopie des globalen Environments als eigene Variablenumgebung zugewiesen bekommt und diese Kopie auch verändern kann. Die Kopie wird aber bei Beenden der Funktion verworfen, so dass Änderungen in der Funktion nicht erhalten bleiben.

Dabei werden die Argumente der Funktion dem Environment der Funktion hinzugefügt, wobei im Zweifelsfall gleichnamige Objekte für die Funktion überschrieben werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{11}\SpecialCharTok{:}\DecValTok{20}

\NormalTok{my\_function }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,y)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{c}\NormalTok{(x,y))}
\NormalTok{\}}

\FunctionTok{my\_function}\NormalTok{(}\DecValTok{21}\NormalTok{,}\DecValTok{22}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 21 22
\end{verbatim}

\hypertarget{aufgabe}{%
\subsection{Aufgabe}\label{aufgabe}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Erstelle eine Funktion mit dem Namen \texttt{my\_mean}, die den Mittelwert eines gegebenen Vektors berechnet.
\item
  Was ergibt der folgende Aufruf:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dummy\_function }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(a,b)\{}
\NormalTok{  a }\SpecialCharTok{*}\NormalTok{ b}
\NormalTok{\}}

\NormalTok{c }\OtherTok{\textless{}{-}} \FunctionTok{dummy\_function}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)}

\FunctionTok{formals}\NormalTok{(dummy\_function)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Was ist am Ende des folgenden Aufrufs in \texttt{number} abgelegt?
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}a number\textquotesingle{}}

\NormalTok{important\_calculation }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(number)\{}
\NormalTok{  number }\OtherTok{\textless{}{-}} \DecValTok{42} \SpecialCharTok{/}\NormalTok{ number }\SpecialCharTok{*}\NormalTok{ number}
  \FunctionTok{return}\NormalTok{(number)}
\NormalTok{\}}

\FunctionTok{important\_calculation}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 42
\end{verbatim}

Antworten

\textbf{1.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_mean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{sum}\NormalTok{(x)}\SpecialCharTok{/}\FunctionTok{length}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{2.}

\begin{verbatim}
## $a
## 
## 
## $b
\end{verbatim}

\textbf{3.}

\texttt{\textquotesingle{}a\ number\textquotesingle{}}

\hypertarget{geschachtelte-funktionen}{%
\section{Geschachtelte Funktionen}\label{geschachtelte-funktionen}}

Um den Code übersichtlicher zu halten, können Teile von Funktionen in andere Funktionen ausgegliedert werden.
Dabei nutzen wir, dass unsere Funktionen auch auf das global Environment zugreifen und Funktionen ja auch nur Arten von Objekten sind.

Wenn wir unsere Funktionen \texttt{greet\_someone} und \texttt{greet\_someone\_n\_times} von vorhin nochmal angucken sehen wir, dass ein Teil des Codes in beiden auftaucht:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(greet\_someone)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(name){
##   return(paste0('Hello ',name,'! Nice to see you!'))
## }
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(greet\_someone\_n\_times)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(name) {
##   
##   n <- 3
##   
##   return(rep(paste0('Hello ', 
##                     name, 
##                     '! Nice to see you!'), 
##              n))
## }
\end{verbatim}

Wir können \texttt{greet\_someone\_n\_times} jetzt so umschreiben, dass sie \texttt{greet\_someone} benutzt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone\_n\_times }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name)\{}
\NormalTok{  n }\OtherTok{\textless{}{-}} \DecValTok{3}
  
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\FunctionTok{greet\_someone}\NormalTok{(name), }
\NormalTok{             n))}
\NormalTok{\}}


\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
## [3] "Hello Marvin! Nice to see you!"
\end{verbatim}

\hypertarget{aufgabe-1}{%
\subsection{Aufgabe}\label{aufgabe-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erstelle eine \texttt{my\_var} Funktion, die die unkorrigierte Varianz eines Vektors (\(S^2 = {1\over{n}} \sum_{i=1}^n(x_i -M_X)^2\)) berechnet. Benutze für den Mittelwert deine Mittelwerts-Funktion aus dem letzten Aufgaben-Block.
\end{enumerate}

Antworten

\textbf{1.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_var }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  m\_x }\OtherTok{\textless{}{-}} \FunctionTok{my\_mean}\NormalTok{(x)}
  
\NormalTok{  x }\OtherTok{\textless{}{-}}\NormalTok{ (x }\SpecialCharTok{{-}}\NormalTok{ m\_x)}\SpecialCharTok{\^{}}\DecValTok{2}
  
  \FunctionTok{return}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\FunctionTok{length}\NormalTok{(x) }\SpecialCharTok{*} \FunctionTok{sum}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{optionale-argumente}{%
\section{Optionale Argumente}\label{optionale-argumente}}

Unsere \texttt{greet\_someone\_n\_times}-Funktion sieht ja im Moment wie folgt aus:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(greet\_someone\_n\_times)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(name){
##   n <- 3
##   
##   return(rep(greet_someone(name), 
##              n))
## }
\end{verbatim}

Ungünstig daran ist noch, dass das \texttt{n} bei jedem Aufruf als Konstante neu definiert ist.

Um dieses n anpassen zu können, können wir es als zweites Argument übergeben, das beim Aufruf festgelegt werden kann:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone\_n\_times }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name, n)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\FunctionTok{greet\_someone}\NormalTok{(name), }
\NormalTok{             n))}
\NormalTok{\}}

\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
## [3] "Hello Marvin! Nice to see you!"
\end{verbatim}

Da wir uns aber das Tippen sparen wollen und nicht jedes Mal unseren Standard-Fall (n=3) explizit machen wollen, können wir dem Argument einen Standardwert zuweisen.

Dadurch machen wir aus dem \texttt{n} ein \emph{optionales Argument}, wie wir es ja auch schon aus anderen Situationen kennen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone\_n\_times }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name, }\AttributeTok{n=}\DecValTok{3}\NormalTok{)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\FunctionTok{greet\_someone}\NormalTok{(name), }
\NormalTok{             n))}
\NormalTok{\}}

\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
## [3] "Hello Marvin! Nice to see you!"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Marvin\textquotesingle{}}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
## [3] "Hello Marvin! Nice to see you!" "Hello Marvin! Nice to see you!"
## [5] "Hello Marvin! Nice to see you!"
\end{verbatim}

\hypertarget{if-statements}{%
\chapter{\texorpdfstring{\texttt{if}-Statements}{if-Statements}}\label{if-statements}}

Als letzten Schritt wollen wir besonders höflich zu speziellen Nutzern sein. So soll der Name `Justus'\footnote{Nicht, dass er uns verklagt.} ausschweifender gegrüßt werden, als alle anderen Namen.

Um das umsetzten zu können, müssen wir irgendwie einen Test einfügen, ob der gegebene Name gleich `Justus' ist.

Dafür können wir ein so genanntes \texttt{if...else}-Statement nutzen.
Die erste Hälfte, das \texttt{if}-Statement ermöglicht es uns, besonderes Verhalten auszulösen, wenn eine logische Bedingung erfüllt ist. Das \texttt{else} danach können wir nutzen um jeden anderen Fall zu definieren:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name)\{}
  \ControlFlowTok{if}\NormalTok{(name }\SpecialCharTok{==} \StringTok{\textquotesingle{}Justus\textquotesingle{}}\NormalTok{)\{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{,name,}\StringTok{\textquotesingle{}! How extraordinarily nice to see you! I hope you are doing well!\textquotesingle{}}\NormalTok{))}
\NormalTok{  \}}\ControlFlowTok{else}\NormalTok{\{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{,name,}\StringTok{\textquotesingle{}! Nice to see you!\textquotesingle{}}\NormalTok{))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Das funktioniert zwar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{greet\_someone}\NormalTok{(}\StringTok{\textquotesingle{}Justus\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Justus! How extraordinarily nice to see you! I hope you are doing well!"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{greet\_someone}\NormalTok{(}\StringTok{\textquotesingle{}Jonas\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Jonas! Nice to see you!"
\end{verbatim}

Und bemerkensweiterweise auch in der geschachtelten Form:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{greet\_someone\_n\_times}\NormalTok{(}\StringTok{\textquotesingle{}Justus\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello Justus! How extraordinarily nice to see you! I hope you are doing well!"
## [2] "Hello Justus! How extraordinarily nice to see you! I hope you are doing well!"
## [3] "Hello Justus! How extraordinarily nice to see you! I hope you are doing well!"
\end{verbatim}

Aber wirklich gut lesbar ist das nicht unbedingt.
Ein gängiger Ansatz, um die Lesbarkeit einer solchen Funktion mit verschiedenen Outputs zu verbessern, ist, nur ein \texttt{return}-statement ans Ende der Funktion zu stellen und die Teil-Änderung durch das \texttt{if}-statement in einem Objekt abzulegen, das im gemeinsamen \texttt{return} genutzt wird. So könnten wir den letzten Teil des Grußes zum Beispiel in einem Objekt namens \texttt{text} ablegen und je nach Nutzer anpassen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name)\{}
  \ControlFlowTok{if}\NormalTok{(name }\SpecialCharTok{==} \StringTok{\textquotesingle{}Justus\textquotesingle{}}\NormalTok{)\{}
\NormalTok{    text }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}! How extraordinarily nice to see you! I hope you are doing well!\textquotesingle{}}
\NormalTok{  \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{    text }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}! Nice to see you!\textquotesingle{}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{,name,text))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ein letzter Trick, um diese Funktion leichter lesbar zu gestalten, ist den Regelfall \emph{vor} das \texttt{if}-statement zu stellen und sich so das \texttt{else} zu sparen. Da die Anweisung im \texttt{if}-statement nur evaluiert wird, wenn der Test positiv aufgeht, ist das Ergebnis der folgenden Funktion äquivalent:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greet\_someone }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(name)\{}
\NormalTok{  text }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}! Nice to see you!\textquotesingle{}}
  
  \ControlFlowTok{if}\NormalTok{(name }\SpecialCharTok{==} \StringTok{\textquotesingle{}Justus\textquotesingle{}}\NormalTok{)\{}
\NormalTok{    text }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}! How extraordinarily nice to see you! I hope you are doing well!\textquotesingle{}}
\NormalTok{  \}}
  
  \FunctionTok{return}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{\textquotesingle{}Hello \textquotesingle{}}\NormalTok{,name,text))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{aufgabe-2}{%
\subsection{Aufgabe}\label{aufgabe-2}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erweitere die \texttt{my\_var}-Funktion um ein optionales \texttt{corrected} Argument, das standardmäßig auf \texttt{TRUE} gesetzt ist. Die Funktion soll, wenn dieses Argument auf \texttt{TRUE} gesetzt ist, die korrigierte(\(s^2 = {1\over{n-1}} \sum_{i=1}^n(x_i -M_X)^2\)); wenn es auf \texttt{FALSE} gesetzt wird die unkorrigierte (\(S^2 = {1\over{n}} \sum_{i=1}^n(x_i -M_X)^2\)) Stichprobenvarianz ausgeben.
\end{enumerate}

Antworten

\textbf{1.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_var }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, }\AttributeTok{corrected=}\ConstantTok{TRUE}\NormalTok{)\{}
\NormalTok{  m\_x }\OtherTok{\textless{}{-}} \FunctionTok{my\_mean}\NormalTok{(x)}
  
\NormalTok{  x }\OtherTok{\textless{}{-}}\NormalTok{ (x }\SpecialCharTok{{-}}\NormalTok{ m\_x)}\SpecialCharTok{\^{}}\DecValTok{2}
  
\NormalTok{  factor }\OtherTok{\textless{}{-}} \DecValTok{1} \SpecialCharTok{/}\NormalTok{ (}\FunctionTok{length}\NormalTok{(x) }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{)}
  
  \ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\NormalTok{corrected)\{}
\NormalTok{    factor }\OtherTok{\textless{}{-}} \DecValTok{1} \SpecialCharTok{/}\NormalTok{ (}\FunctionTok{length}\NormalTok{(x))}
\NormalTok{  \}}
  
  \FunctionTok{return}\NormalTok{(factor }\SpecialCharTok{*} \FunctionTok{sum}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{zufallswerte}{%
\chapter{Zufallswerte}\label{zufallswerte}}

Mit R kann man sehr einfach quasi-zufällige\footnote{Es ist für einen Rechner sehr schwierig, wahren Zufall zu erzeugen. Auf der Hilfeseite \texttt{?Random} kann man sich eine Liste der Algorithmen anschauen, die R zur Generation quasi-zufälliger Wertfolgen nutzt. Diese nicht-wirklich-zufällige Natur der Wertfolgen hat aber auch den Vorteil, dass wir ``zufällige'' Ergebnisse reproduzierbar machen können. mit \texttt{set.seed()} können wir einen Startwert für die Zufalls-Generation festlegen, den andere R-Nutzer dann auch wählen können.} Wertreihen erstellen. Aus der Veranstaltung letztes Semester kennen wir ja schon die Funktion \texttt{sample}, die aus einer vorgegebenen Urne ziehen kann.

Für unsere Simulations-Probleme gibt es noch eine andere Reihe an Funktionen, die für eine feste Verteilungsklasse zufällige Wertfolgen erstellen können.

Diese Funktionen werden mit einem \texttt{r} für \emph{random} und der Verteilungsklasse aufgerufen. Eine Übersicht der implementierten Verteilungen kann man mit \texttt{?Distributions} aufrufen.

Mit diesen Funktionen können wir uns zum Beispiel jeweils 1000 zufällige Werte aus einer \(N(0,5)-\), einer \(B(20000, 1/6)-\), einer \(t(50)\)- und einer \(F(12,36)-\)Verteilung ziehen und in Histogrammen darstellen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{norm =} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{,}\AttributeTok{mean =} \DecValTok{0}\NormalTok{,}\AttributeTok{sd =} \FunctionTok{sqrt}\NormalTok{(}\DecValTok{5}\NormalTok{)),}
       \AttributeTok{binom =} \FunctionTok{rbinom}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\AttributeTok{size =} \DecValTok{20000}\NormalTok{,}\AttributeTok{prob =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{6}\NormalTok{),}
       \AttributeTok{t =} \FunctionTok{rt}\NormalTok{(}\DecValTok{1000}\NormalTok{,}\AttributeTok{df =} \DecValTok{50}\NormalTok{),}
       \AttributeTok{f =} \FunctionTok{rf}\NormalTok{(}\DecValTok{1000}\NormalTok{,}\AttributeTok{df1 =} \DecValTok{12}\NormalTok{,}\AttributeTok{df2 =} \DecValTok{36}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_longer}\NormalTok{(}\FunctionTok{everything}\NormalTok{(),}
               \AttributeTok{names\_to =} \StringTok{\textquotesingle{}dist\textquotesingle{}}\NormalTok{,}
               \AttributeTok{values\_to =} \StringTok{\textquotesingle{}sample\textquotesingle{}}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ sample)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{fill =} \StringTok{\textquotesingle{}white\textquotesingle{}}\NormalTok{,}
                 \AttributeTok{color =} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{,}
                 \AttributeTok{bins =} \DecValTok{40}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{dist,}\AttributeTok{scales =} \StringTok{\textquotesingle{}free\_x\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-35-1.pdf}

\hypertarget{aufgabe-3}{%
\subsection{Aufgabe}\label{aufgabe-3}}

Erstelle eine Funktion \texttt{gen\_distributed\_values}, die mit Hilfe von \texttt{if}-Statements anhand eines Arguments \texttt{distribution} und eines Arguments \texttt{n} einen Vektor an Zufallszahlen generiert. Dabei soll \texttt{distribution} angeben, welche aus drei möglichen Verteilungen genutzt wird. Denke außerdem an mögliche Verteilungseigenschaften der genutzten Funktionen und füge sie als optionale Argumente zur Funktion hinzu.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gen\_distributed\_values }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(distribution,}
\NormalTok{                                   n,}
                                   \AttributeTok{df =} \DecValTok{1}\NormalTok{,}
                                   \AttributeTok{lambda =} \DecValTok{25}\NormalTok{,}
                                   \AttributeTok{rate =} \DecValTok{5}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{(distribution }\SpecialCharTok{==} \StringTok{\textquotesingle{}t\textquotesingle{}}\NormalTok{)\{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{rt}\NormalTok{(n, df))}
\NormalTok{  \}}\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(distribution }\SpecialCharTok{==} \StringTok{\textquotesingle{}pois\textquotesingle{}}\NormalTok{)\{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{rpois}\NormalTok{(n, lambda))}
\NormalTok{  \}}\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(distribution }\SpecialCharTok{==} \StringTok{\textquotesingle{}exp\textquotesingle{}}\NormalTok{)\{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{rexp}\NormalTok{(n, rate))}
\NormalTok{  \}}
  \FunctionTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Distribution is not implemented, returning zeros\textquotesingle{}}\NormalTok{)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{numeric}\NormalTok{(n))}
\NormalTok{\}}

\FunctionTok{gen\_distributed\_values}\NormalTok{(}\StringTok{\textquotesingle{}pois\textquotesingle{}}\NormalTok{,}
                       \DecValTok{5}\NormalTok{,}
                       \AttributeTok{lambda =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 4 3 5 2
\end{verbatim}

\hypertarget{schleifen}{%
\chapter{Schleifen}\label{schleifen}}

Bei so gut wie allen Simulationsproblemen stehen wir vor der Situation, dass wir eine Operation, zum Beispiel das Generieren einer gewissen Zahl an Zufallswerten und die Berechnung der zugehörigen Teststatistik, mehrere hundert Mal ausführen wollen.

Wir könnten jetzt die Operation mehrere hundert mal in unser Skript schreiben, damit würden wir aber zum Einen Fehler einladen, zum Anderen viel zu viel Lebenszeit verschwenden.

Deswegen gibt es in so gut wie jeder Programmiersprache irgendeine Form von Ausdrücken, die eine \emph{iterative} Wiederholung eines Ausdrucks ermöglichen.

Ein Beispiel für die Anweisung einer solchen iterativen Wiederholung sind Schleifen.
In R gibt es davon drei Arten:

\begin{itemize}
\item
  \texttt{repeat} - die flexibelste Schleife, die so lange wiederholt bis sie mit \texttt{break} unterbrochen wird
\item
  \texttt{while} - eine Schleife, die zu Beginn jeder Wiederholung einen logischen Test durchführt und bei Zutreffen die Operation wiederholt
\item
  \texttt{for} - die unflexibelste der drei Möglichkeiten. \texttt{for} iteriert einen Wert durch einen Vektor oder eine Liste, bis alle Einträge einmal dran waren. Das heißt, dass wir eine feste Laufzeit und damit den einfachsten Umgang haben, weswegen wir auch \texttt{for} in diesem Kurs verwenden werden.
\end{itemize}

Die \texttt{for}-Syntax sieht dabei wie folgt aus:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(value }\ControlFlowTok{in}\NormalTok{ vector)\{}
\NormalTok{  do something}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Um jetzt Beispielsweise alle Werte von eins bis zehn durch zu laufen und jeden Wert auszugeben können wir den folgenden Ausdruck benutzen:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(}\DecValTok{10}\NormalTok{))\{}
  \FunctionTok{print}\NormalTok{(i)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
\end{verbatim}

Wie man an diesem Beispiel schon sehen kann, können wir in der Schleife auf den \texttt{i}-Wert zugreifen. Das können wir zum Beispiel benutzen, um die ersten zehn Zahlen der Fibonacci-Reihe zu berechnen, in der jeder Wert die Summe der zwei vorhergegangenen ist:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fib }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(fib))\{}
  \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\textless{}}\DecValTok{3}\NormalTok{)\{ }\CommentTok{\# die ersten zwei Stellen müssen Einsen sein}
\NormalTok{    fib[i] }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{  \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{    fib[i] }\OtherTok{\textless{}{-}}\NormalTok{ fib[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ fib[i}\DecValTok{{-}2}\NormalTok{] }\CommentTok{\# nimm die letzten zwei Einträge und summier sie auf}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{fib}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  1  2  3  5  8 13 21 34 55
\end{verbatim}

In diesem Beispiel ist noch ein weiteres Programmier-Prinzip sichtbar, die \emph{Allokation} des Ergebnis-Vektors vor der Berechnung der Werte. Damit ist einfach gemeint, dass wir den leeren \texttt{fib}-Vektor erstellt haben, bevor wir mit der Schleife angefangen haben.

Der Grund für dieses Vorgehen ist, dass jedes Anlegen eines Vektors einer bestimtmen Größe ein bisschen Rechenzeit kostet. Wenn wir von vornherein festlegen, wie lang der Vektor werden soll, müssen wir nur einen Vektor anlegen. Wenn wir stattdessen wie im folgenden Beispiel in jeder Iteration den Vektor vergrößern, erstellt R implizit in jeder Iteration einen neuen Vektor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fib }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(}\DecValTok{10}\NormalTok{))\{}
  \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\textless{}}\DecValTok{3}\NormalTok{)\{ }
\NormalTok{    fib[i] }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{  \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{    fib[i] }\OtherTok{\textless{}{-}}\NormalTok{ fib[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ fib[i}\DecValTok{{-}2}\NormalTok{] }
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{fib}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  1  2  3  5  8 13 21 34 55
\end{verbatim}

Bei 10 Stellen ist der Unterschied noch nicht wirklich bemerkbar. Wenn wir jetzt aber das ganze in Funktionen verpacken und für längere Sequenzen laufen lassen und die Laufzeit stoppen sehen wir den Unterschied:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fib\_alloc }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  fib }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(n)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_along}\NormalTok{(fib))\{}
    \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\textless{}}\DecValTok{3}\NormalTok{)\{ }
\NormalTok{      fib[i] }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{    \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{      fib[i] }\OtherTok{\textless{}{-}}\NormalTok{ fib[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ fib[i}\DecValTok{{-}2}\NormalTok{] }
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(fib)}
\NormalTok{\}}


\NormalTok{fib\_no\_alloc }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  fib }\OtherTok{\textless{}{-}} \DecValTok{1}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(n))\{}
    \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\textless{}}\DecValTok{3}\NormalTok{)\{ }
\NormalTok{      fib[i] }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{    \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{      fib[i] }\OtherTok{\textless{}{-}}\NormalTok{ fib[i}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ fib[i}\DecValTok{{-}2}\NormalTok{] }
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(fib)}
\NormalTok{\}}
\NormalTok{start }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{()}
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{fib\_alloc}\NormalTok{(}\DecValTok{100000}\NormalTok{)}
\NormalTok{runtime\_alloc }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{() }\SpecialCharTok{{-}}\NormalTok{ start}
\NormalTok{start }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{()}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{fib\_no\_alloc}\NormalTok{(}\DecValTok{100000}\NormalTok{)}
\NormalTok{runtime\_no\_alloc }\OtherTok{\textless{}{-}} \FunctionTok{Sys.time}\NormalTok{() }\SpecialCharTok{{-}}\NormalTok{ start}

\NormalTok{runtime\_alloc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of 0.03624272 secs
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{runtime\_no\_alloc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Time difference of 0.07664776 secs
\end{verbatim}

Mehr als die Hälfte der Zeit geht für das Erstellen des neuen Vektors drauf!

\hypertarget{aufgabe-4}{%
\subsection{Aufgabe}\label{aufgabe-4}}

In QM-2 habt Ihr im Rahmen des zentralen Grenzwertsatzes gelernt, dass die Verteilungsfunktion der z-Transformation der n-ten Summe einer Reihe von unabhängigen Zufallsvariablen für wachsendes n schwach gegen die Standardnormalverteilung konvergiert.

Schreibe eine Funktion, die für eine gegebene Anzahl an Summen und eine gegebene Verteilungsklasse (und den entsprechenden Parametern inklusive der Stichprobengröße) einen Vektor mit den entsprechenden Summen zurückgibt.
Nutze dafür deine Funktion aus der letzten Aufgabe.

Nutze diese Funktion dann um ein Histogramm mit 5000 dieser z-transformierten Summen zu erstellen.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gen\_central\_lim\_vec }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(N, }
\NormalTok{                                distribution,}
\NormalTok{                                n,}
                                \AttributeTok{df =} \DecValTok{1}\NormalTok{,}
                                \AttributeTok{lambda =} \DecValTok{25}\NormalTok{,}
                                \AttributeTok{rate =} \DecValTok{5}\NormalTok{) \{}
  
\NormalTok{  ret\_vec }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(N)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(N))\{}
\NormalTok{    ret\_vec[i] }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(}\FunctionTok{gen\_distributed\_values}\NormalTok{(distribution,}
\NormalTok{                                      n,}
\NormalTok{                                      df,}
\NormalTok{                                      lambda,}
\NormalTok{                                      rate))}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(ret\_vec)}
\NormalTok{\}}

\FunctionTok{tibble}\NormalTok{(}\AttributeTok{sample =} \FunctionTok{scale}\NormalTok{(}\FunctionTok{gen\_central\_lim\_vec}\NormalTok{(}\DecValTok{5000}\NormalTok{, }\StringTok{\textquotesingle{}exp\textquotesingle{}}\NormalTok{, }\DecValTok{1000}\NormalTok{,}\AttributeTok{rate =} \DecValTok{5}\NormalTok{))) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ sample)) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\AttributeTok{binwidth =}\NormalTok{ .}\DecValTok{1}\NormalTok{,}
                 \AttributeTok{color =} \StringTok{\textquotesingle{}grey\textquotesingle{}}\NormalTok{,}
                 \AttributeTok{fill =} \StringTok{\textquotesingle{}white\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-42-1.pdf}

\hypertarget{listen}{%
\chapter{Listen}\label{listen}}

Listen sind uns aus der R-Übung schon im Rahmen der \href{https://mbrede.github.io/CAU_Kiel_EDVI/aggregation-und-filemanagement.html\#lazy-evaluation}{Gruppenweisen Aggregation mit \texttt{across}} und \href{https://mbrede.github.io/CAU_KIEL_EDVII/einfache-lineare-zusammenh\%C3\%A4nge.html\#weitere-parameter}{als Output von Inferenzstatistischen Funktionen} untergekommen.
Aber was genau Listen architektonisch sind, haben wir bisher übergangen.

Listen sind in R ziemlich ähnlich zu Vektoren \footnote{Wobei der Ausdruck ``Vektoren'' hier irreführend ist, in R wird eigentlich die Eltern-Klasse der Objekte \texttt{Vector} genannt, zu der \texttt{Atomic}(unsere ``Vektoren'') und \texttt{List} gehören. Da wir aber in den Grundlagenfächern wegen der mathematischen Analogie ``Vektor'' zu den \texttt{Atomic}-Objekten gesagt haben, behalten wir das hier bei.}. Sie bilden Aneinander-Kettungen von Objekten ab, bei denen wir die einzelnen Elemente benennen können.
Ein Unterschied zu Vektoren ist aber, dass die Objekte nicht von einem einzelnen Typ sein müssen.
Ein anderer Unterschied wird deutlich, wenn wir uns den Output von benannten Vektoren und Listen genauer anschauen.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\OtherTok{=} \DecValTok{1}\NormalTok{,}
  \StringTok{\textquotesingle{}b\textquotesingle{}}\OtherTok{=} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a b 
## 1 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{list}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\OtherTok{=} \DecValTok{1}\NormalTok{,}
     \StringTok{\textquotesingle{}b\textquotesingle{}}\OtherTok{=} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $a
## [1] 1
## 
## $b
## [1] 2
\end{verbatim}

Die Ausgabe der Liste ähnelt unter der jeweiligen Überschrift (z.B.: \texttt{\$a}) dem Output, den wir bei einem unbenannten Vektor sehen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

Das liegt daran, dass in einer Liste unter dem Namen auch der ganze Vektor ``abgespeichert'' ist. Abgespeichert ist hier in Anführungszeichen, da in der Liste eigentlich nur ein Verweis auf einen Vektor liegt. Das kann man sich verdeutlichen, wenn man sich die Größen von Vektoren und Listen im Arbeitsspeicher anguckt.

Dazu erstellen wir einen Vektoren mit den Zahlen von 1:1000 und eine Liste, der wir dreimal diesen Vektor übergeben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{1000}\NormalTok{)}

\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{a =}\NormalTok{ a, }\AttributeTok{b =}\NormalTok{ a, }\AttributeTok{c =}\NormalTok{ a, }\AttributeTok{d =}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

Wenn wir uns jetzt die Größen der beiden Objekte angucken, sehen wir dass die Liste kleiner ist, als vielleicht zuerst erwartet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4,048 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4,544 B
\end{verbatim}

Wenn wir die Liste mit einem vergleichbaren Vektor gegenüberstellen sehen wir, dass dieser die Werte offensichtlich direkt ablegt, wohingegen die Liste die Werte nur einmal beinhaltet (plus ein bisschen Speicher für die wiederholten Verweise und Namen):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(a, a, a, a)}

\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4,048 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4,544 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 16,048 B
\end{verbatim}

Was passiert nun, wenn wir einen Teil eines der vier Einträge in der Liste ändern?

Dazu können wir die schon von \texttt{data.frames} bekannte Index-Variante mit dem \texttt{\$}-Operator nutzen um einen der Vektoren in der Liste zu modifizieren:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}\SpecialCharTok{$}\NormalTok{a[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 12,592 B
\end{verbatim}

Die Liste wird größer. Dass sie nicht in Inkrementen von 4000 B größer wird, liegt daran, dass die Zahlen in \texttt{a} als Sequenz von R effizienter gespeichert werden können, als als einfache Zahlen. Wenn wir uns \texttt{a} alleine angucken und die Größe vor und nach Änderung der ersten Stelle betrachten, wird das deutlich:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4,048 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{5}

\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 8,048 B
\end{verbatim}

Für mehr Details zu diesem Speicher-Verhalten und dem zugrunde liegenden Prinzip ist das kostenlos \href{https://adv-r.hadley.nz/index.html}{hier zugängliche} Buch ``Advanced R'' \citet{wickhamAdvanced2019} sehr gut, vor allem die \href{https://adv-r.hadley.nz/names-values.html\#binding-basics}{Kapitel 2.2} und folgende und das \href{https://adv-r.hadley.nz/vectors-chap.html}{Kapitel über Vektoren}.

\hypertarget{aufgabe-5}{%
\subsubsection{Aufgabe}\label{aufgabe-5}}

Überlege dir, wie sich der Speicherbedarf der Liste \texttt{b} ändert, wenn Du den zweiten Platz der Liste mit dem ersten Platz der Liste überschreibst.
Probiere dann aus, ob sich deine Vorhersage bewahrheitet.
Überprüfe dann, was passiert, wenn du die erste Stelle des dritten Platzes der Liste durch fünf ersetzt.
Was könnte hier passiert sein?

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{1000}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{a =}\NormalTok{ a,}\AttributeTok{b =}\NormalTok{ a,}\AttributeTok{c =}\NormalTok{ a,}\AttributeTok{d =}\NormalTok{ a)}
\NormalTok{b}\SpecialCharTok{$}\NormalTok{a[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 12,592 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}\SpecialCharTok{$}\NormalTok{b }\OtherTok{\textless{}{-}}\NormalTok{ b}\SpecialCharTok{$}\NormalTok{a}
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 12,592 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}\SpecialCharTok{$}\NormalTok{c[}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{lobstr}\SpecialCharTok{::}\FunctionTok{obj\_size}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 20,640 B
\end{verbatim}

\hypertarget{listen-und-datensuxe4tze}{%
\section{Listen und Datensätze}\label{listen-und-datensuxe4tze}}

Das Arbeiten mit Listen ist ziemlich ähnlich zu der mit Datensätzen.
Das liegt ganz einfach daran, dass Datensätze auch Listen sind, der einzige wirklich wichtige Unterschied ist, dass Datensätze im Vergleich zu Listen einheitliche Längen von den eingefügten Vektoren erwarten.

Zu sehen ist dieses Verhältnis ganz einfach, wenn man sich den \texttt{mode} eines Datensatzes anguckt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}
                \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}

\FunctionTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.frame"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mode}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

Der Unterschied ist in den \texttt{attributes} des Datensatzes festgelegt.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $names
## [1] "X1.10"   "X1.10.1"
## 
## $class
## [1] "data.frame"
## 
## $row.names
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

Nur zum Spaß können wir so auch versuchen, umständlich einen Datensatz zu erstellen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\FunctionTok{attributes}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(a) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{names =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{],}
                      \AttributeTok{row.names =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}
                      \AttributeTok{class =} \StringTok{"data.frame"}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     a  b
## 1   1  1
## 2   2  2
## 3   3  3
## 4   4  4
## 5   5  5
## 6   6  6
## 7   7  7
## 8   8  8
## 9   9  9
## 10 10 10
\end{verbatim}

\hypertarget{aufgabe-6}{%
\subsubsection{Aufgabe}\label{aufgabe-6}}

Überlege Dir, was wohl passiert, wenn du auf die gerade demonstrierte Art und Weise einen Datensatz erstellst, bei dem die eingefügten Vektoren von unterschiedlicher Länge sind.
Überprüfe dann, ob die Erwartungen stimmen.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{15}\NormalTok{,}\DecValTok{21}\SpecialCharTok{:}\DecValTok{30}\NormalTok{,}\DecValTok{41}\SpecialCharTok{:}\DecValTok{45}\NormalTok{)}
\FunctionTok{attributes}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(a) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{names =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{],}
                      \AttributeTok{row.names =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}
                      \AttributeTok{class =} \StringTok{"data.frame"}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :
## corrupt data frame: columns will be truncated or padded with NAs
\end{verbatim}

\begin{verbatim}
##     a  b    c
## 1   1 21   41
## 2   2 22   42
## 3   3 23   43
## 4   4 24   44
## 5   5 25   45
## 6   6 26 <NA>
## 7   7 27 <NA>
## 8   8 28 <NA>
## 9   9 29 <NA>
## 10 10 30 <NA>
\end{verbatim}

\hypertarget{arbeiten-mit-listen}{%
\section{Arbeiten mit Listen}\label{arbeiten-mit-listen}}

Da Datensätze eigentlich nur Listen sind, gibt es Listen-Operationen die wir schon von Datensätzen kennen, bei denen wir einfach noch nicht wussten, dass sie eigentlich aus dem Listen-Kontext stammen.

Insbesondere sind die Operationen, die wir auch schon hier im Skript genutzt haben, Listen-Operationen, die wir aus dem \texttt{data.frame}-Kontext kennen.
Da wären das Anlegen von Spalten/Listen-Einträgen mit Namen, wie wir es eben gesehen haben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{a =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{a =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Und das Indizieren mit dem \texttt{\$}-Operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\SpecialCharTok{$}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}\SpecialCharTok{$}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

Als kleinen Zusatz können wir uns noch die numerische Indizierung angucken, die bei Listen und damit auch Datensätzen mit doppelten eckigen Klammern funktioniert (\texttt{{[}{[}{]}{]}}). Dieser Index-Operator ist hilfreich, wenn nicht jedes mal für jeden Eintrag ein Name angelegt werden soll. Das kann zum Beispiel sinnvoll bei \texttt{functional}-Iteratoren sein, bei denen man nur eine schnelle Stapelverarbeitung plant, dazu aber später mehr.

Bei Listen und Datensätzen sieht der \texttt{{[}{[}{]}{]}}-Einsatz dann so aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\hypertarget{aufgabe-7}{%
\subsubsection{Aufgabe}\label{aufgabe-7}}

Baue ein Skript, das eine Liste erstellt, die drei Einträge enthält.
Jeder dieser Einträge soll auch wieder eine Liste sein.
Das Skript soll nun mit Hilfe einer Schleife die Zahlen von 1 bis 100 durchgehen und alle durch 2 teilbaren Zahlen in den zweiten Eintrag, alle durch 3 teilbaren Zahlen in den dritten Eintrag und alle restlichen Zahlen in den ersten Eintrag einfügen.
Nutze hierfür den ``Modulo''-Operator \texttt{\%\%}, der den `Rest' einer Ganzzahldivision ausgibt.
Überlege dir, wie du mit Zahlen wie der 6 umgehst, die sowohl durch 3 als auch durch 2 teilbar sind.
Kleiner Tipp: \texttt{length} kann hier sehr hilfreich sein.

Zusatzaufgabe:
Überlege dir, wie man dieses Skript so umbauen könnte, dass es für einen Vektor mit beliebigen Teilern funktioniert.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{divisions }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\FunctionTok{list}\NormalTok{(), }\FunctionTok{list}\NormalTok{(), }\FunctionTok{list}\NormalTok{())}

\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{)\{}
  \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\%\%}\DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)\{}
\NormalTok{    divisions[[}\DecValTok{2}\NormalTok{]][[}\FunctionTok{length}\NormalTok{(divisions[[}\DecValTok{2}\NormalTok{]]) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\%\%}\DecValTok{3} \SpecialCharTok{==} \DecValTok{0}\NormalTok{)\{}
\NormalTok{    divisions[[}\DecValTok{3}\NormalTok{]][[}\FunctionTok{length}\NormalTok{(divisions[[}\DecValTok{3}\NormalTok{]]) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{(i}\SpecialCharTok{\%\%}\DecValTok{2} \SpecialCharTok{!=} \DecValTok{0} \SpecialCharTok{\&}\NormalTok{ i}\SpecialCharTok{\%\%}\DecValTok{3} \SpecialCharTok{!=} \DecValTok{0}\NormalTok{)\{}
\NormalTok{    divisions[[}\DecValTok{1}\NormalTok{]][[}\FunctionTok{length}\NormalTok{(divisions[[}\DecValTok{1}\NormalTok{]]) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{  \}}
\NormalTok{\}}
\FunctionTok{summary}\NormalTok{(divisions)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      Length Class  Mode
## [1,] 33     -none- list
## [2,] 50     -none- list
## [3,] 33     -none- list
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Zusatz:}
\NormalTok{divisions }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\FunctionTok{list}\NormalTok{()) }\CommentTok{\# mit einer leeren Liste für die nicht{-}teilbaren initiieren}
\NormalTok{divider }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{9}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in}\NormalTok{ divider)\{}
\NormalTok{  divisions[[i]] }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{()}
\NormalTok{\}}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{)\{}
\NormalTok{  divided }\OtherTok{\textless{}{-}}\NormalTok{  F}
  \ControlFlowTok{for}\NormalTok{(j }\ControlFlowTok{in}\NormalTok{ divider)\{}
    \ControlFlowTok{if}\NormalTok{(i }\SpecialCharTok{\%\%}\NormalTok{ j }\SpecialCharTok{==} \DecValTok{0}\NormalTok{)\{}
\NormalTok{      divisions[[j]][[}\FunctionTok{length}\NormalTok{(divisions[[j]]) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{      divided }\OtherTok{\textless{}{-}}\NormalTok{ T}
\NormalTok{    \}}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\NormalTok{divided)\{}
\NormalTok{    divisions[[}\DecValTok{1}\NormalTok{]][[}\FunctionTok{length}\NormalTok{(divisions[[}\DecValTok{1}\NormalTok{]]) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]] }\OtherTok{\textless{}{-}}\NormalTok{ i}
\NormalTok{  \}}
\NormalTok{\}}

\FunctionTok{summary}\NormalTok{(divisions)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       Length Class  Mode
##  [1,] 22     -none- list
##  [2,] 50     -none- list
##  [3,] 33     -none- list
##  [4,]  0     -none- NULL
##  [5,] 20     -none- list
##  [6,]  0     -none- NULL
##  [7,] 14     -none- list
##  [8,]  0     -none- NULL
##  [9,] 11     -none- list
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unlist}\NormalTok{(divisions[[}\DecValTok{1}\NormalTok{]]) }\CommentTok{\# Mit Teilern und ohne 1 haben wir hier die Primzahlen bis 100 gesammelt.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
\end{verbatim}

\hypertarget{attribute}{%
\chapter{Attribute}\label{attribute}}

Bei der sehr umständlichen Erstellung des Datensatzes haben wir schon die \texttt{attributes} kennen gelernt. Diese Informationen, die in R zu einem Objekt neben dem eigentlichen Inhalt angelegt werden können, sind ein wichtiger Teil der Abbildung objektorientierter Programmierparadigmen\footnote{Was genau objektorientierte Programmierung ist, ist hier erstmal nicht so wichtig, im Prinzip sind aber alle Objekte mit \texttt{class}-Attribut nach objektorientierten Paradigmen erstellt. Hier wird das nur erwähnt, weil es die Geschichte von R als Nachfolger von S demonstriert, in dem ursprünglich ``moderne'' Paradigmen nicht Thema waren. Die Erweiterung der bestehenden Objekte durch das Setzen von Attributen ist die Lösung für dieses Problem, die in Rs \texttt{S3}-Objekten resultieren. Daneben gibt es in R die \texttt{S4}-Objekte, die formalisiertere Klassendefinitionen ermöglichen. Das führt aber alles ein bisschen weit für diese Veranstaltung, deswegen sei hier nochmal auf das sehr gute Buch von \citet{wickhamAdvanced2019} verwiesen, in den Kapiteln 13-15 geht er auf OO-Programmierung in R ein.} in R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)}
\FunctionTok{attributes}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(a) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{names =}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{],}
                      \AttributeTok{row.names =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}
                      \AttributeTok{class =} \StringTok{"data.frame"}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     a  b
## 1   1  1
## 2   2  2
## 3   3  3
## 4   4  4
## 5   5  5
## 6   6  6
## 7   7  7
## 8   8  8
## 9   9  9
## 10 10 10
\end{verbatim}

Neben der Klasse (\texttt{class}) haben wir hier in die \texttt{attributes} auch die Namen der Einträge und die Zeilennamen geschrieben. Wir sehen also, dass der sichtbare und bemerkbare Unterschied zwischen Listen und Datensätzen aus dem Setzen dieser Attribute entsteht. Außerdem wird an diesem Beispiel deutlich, dass die Funktionen, die wir bisher zum Erstellen von Datensätzen genutzt haben, auch eigentlich nur Attribute setzen.
Attribute sind also zusätzliche Informationen, die den Umgang mit Objekten ändern können.

Ein weiteres Beispiel für solche Änderungen durch Attribute sind Matritzen. In R kann man mit der \texttt{matrix}-Funktion zweidimensionale Daten-Raster erstellen, für die zum Beispiel auch die dimensionierte Indizierung \texttt{{[},{]}} definiert ist:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{100}\NormalTok{,}
       \AttributeTok{nrow =} \DecValTok{10}\NormalTok{, }
       \AttributeTok{ncol =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1   11   21   31   41   51   61   71   81    91
##  [2,]    2   12   22   32   42   52   62   72   82    92
##  [3,]    3   13   23   33   43   53   63   73   83    93
##  [4,]    4   14   24   34   44   54   64   74   84    94
##  [5,]    5   15   25   35   45   55   65   75   85    95
##  [6,]    6   16   26   36   46   56   66   76   86    96
##  [7,]    7   17   27   37   47   57   67   77   87    97
##  [8,]    8   18   28   38   48   58   68   78   88    98
##  [9,]    9   19   29   39   49   59   69   79   89    99
## [10,]   10   20   30   40   50   60   70   80   90   100
\end{verbatim}

\hypertarget{aufgabe-8}{%
\subsubsection{Aufgabe}\label{aufgabe-8}}

Erstelle eine Matrix und gucke die genau die Attribute und Inhalte an.

Können wir so wie wir einen Datensatz aus einer Liste erstellt haben, irgendwie ohne die \texttt{matrix}-Funktion eine Matrix erstellen? Gucke Dir dabei nach jeder Änderung an, was \texttt{class} und \texttt{mode} zurückgeben.

Probiere außerdem aus, was passiert, wenn man die Attribute einer Matrix auf eine Liste überträgt.

\textbf{Zusatz:}

Was passiert, wenn wir der Liste drei Dimensionen geben?

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{],}
                 \DecValTok{4}\NormalTok{)}

\FunctionTok{attributes}\NormalTok{(my\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $dim
## [1] 4 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mode}\NormalTok{(my\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(my\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix" "array"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_list\_mat }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,}\DecValTok{6}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\DecValTok{11}\SpecialCharTok{:}\DecValTok{15}\NormalTok{,}\DecValTok{16}\SpecialCharTok{:}\DecValTok{20}\NormalTok{)}

\FunctionTok{attributes}\NormalTok{(my\_list\_mat) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\NormalTok{my\_list\_mat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]      [,2]     
## [1,] integer,5 integer,5
## [2,] integer,5 integer,5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mode}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix" "array"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Zusatz}
\NormalTok{my\_list\_mat }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }
                    \DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }
                    \DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }
                    \DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{)}

\FunctionTok{attributes}\NormalTok{(my\_list\_mat) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{))}
\NormalTok{my\_list\_mat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,] 1    3    5    7   
## [2,] 2    4    6    8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mode}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix" "array"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(my\_list\_mat) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\NormalTok{my\_list\_mat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## , , 1
## 
##      [,1] [,2]
## [1,] 1    3   
## [2,] 2    4   
## 
## , , 2
## 
##      [,1] [,2]
## [1,] 5    7   
## [2,] 6    8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mode}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "array"
\end{verbatim}

Mit anderen Worten ist eine Matrix als ein Array definiert, das (egal ob Liste oder Vektor), zwei Dimensionen hat. Mit mehr als zwei Dimensionen fällt die Matrix-Klasse weg.

Die Matrix-Listen aus der Aufgabe können wir übrigens auch wie Matrizen verwenden:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{attributes}\NormalTok{(my\_list\_mat) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{))}

\FunctionTok{t}\NormalTok{(my\_list\_mat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,] 1    2   
## [2,] 3    4   
## [3,] 5    6   
## [4,] 7    8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_list\_mat[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 3
\end{verbatim}

Das Ergebnis ist halt nur eine Liste, was mit dem bekannten doppel-Index aber auch umgangen werden kann:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_list\_mat[[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\hypertarget{functionals}{%
\chapter{Functionals}\label{functionals}}

Wie wir am Anfang des Semesters bei der Definition unserer eigenen Funktionen ja schon gemerkt haben, sind Funktionen in R von der Struktur her gar nicht so verschieden zu anderen Objekten wie zum Beispiel Datensätzen oder Vektoren.

Sowohl die einen, wie auch die anderen, werden als Namen mit entsprechenden Inhalten im Environment angelegt, wobei aber natürlich bei Datensätzen die Daten damit gemeint sind und bei Funktionen \emph{Environment}-Verweis, \emph{Body} und \emph{Formals} angelegt werden.

Das heißt für R aber auch, dass so genannte \emph{Functionals} genutzt werden. Diese Gruppe von Funktionen sind solche, die andere Funktionen als Argumente und diese anwenden können. Beispiele für solche Funktionen haben wir auch schon kennen gelernt, die vielleicht aus dem Kapitel zur \href{https://mbrede.github.io/CAU_Kiel_EDVI/aggregation-und-filemanagement.html}{Aggregation} von Daten in EDV1 bekannte \texttt{across}-Funktion ist ein solcher Fall:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(Species) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{summarise}\NormalTok{(}\FunctionTok{across}\NormalTok{(}\FunctionTok{where}\NormalTok{(is.numeric),}
                   \AttributeTok{.fns =} \FunctionTok{list}\NormalTok{(}\AttributeTok{m =}\NormalTok{ mean, }\AttributeTok{s =}\NormalTok{ sd),}
                   \AttributeTok{.names =} \StringTok{\textquotesingle{}\{.fn\}\_\{.col\}\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 9
##   Species    m_Sepal.Length s_Sepal.Length m_Sepal.Width s_Sepal.Width
##   <fct>               <dbl>          <dbl>         <dbl>         <dbl>
## 1 setosa               5.01          0.352          3.43         0.379
## 2 versicolor           5.94          0.516          2.77         0.314
## 3 virginica            6.59          0.636          2.97         0.322
## # ... with 4 more variables: m_Petal.Length <dbl>, s_Petal.Length <dbl>,
## #   m_Petal.Width <dbl>, s_Petal.Width <dbl>
\end{verbatim}

Hier übergeben wir dem \texttt{.fns}-Argument eine Liste mit Funktionen, die dann auf alle numerischen Spalten des Datensatzes angewandt werden.

Ein anderes, sehr für R typisches Beispiel von Functionals sind \texttt{sapply}, \texttt{lapply} und \texttt{mapply}. Alle drei Funktionen nehmen als Input eins oder mehrere Objekte und eine Funktion, die auf jeden Eintrag de(s/r) übergebenen Objekte(s) angewandt werden soll.

Exemplarisch gucken wir uns \texttt{sapply} an, die Listen\footnote{oder Vektoren} als erstes Argument erwarten.
Als Objekt nehmen wir \texttt{iris} (was ja wie wir gelernt habe eine aufgemotzte Liste ist) und lassen uns mit \texttt{sapply} für jede Spalte sagen, ob sie numerisch ist:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(iris, is.numeric)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##         TRUE         TRUE         TRUE         TRUE        FALSE
\end{verbatim}

Fällt Dir was auf?
Wir haben gerade eine Funktion fünf mal ausgeführt, ohne ihr explizit ein Argument zu übergeben. Den (\texttt{is.numeric(iris\$Sepal.Width)},\texttt{is.numeric(iris\$Sepal.Length)}, etc., etc., \ldots)-Teil hat uns \texttt{sapply} abgenommen. \texttt{sapply} ist sogar so weit gegangen, uns die Ergebnisse in einem praktischen Vektor wiederzugeben, hat also irgendwie einen Output für uns erstellt.

Diesen Vektor könnten wir jetzt als Index nutzen, um uns nur die numerischen Spalten ausgeben zu lassen und uns wieder mit \texttt{sapply} die Mittelwerte ausrechnen zu lassen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(iris[,}\FunctionTok{which}\NormalTok{(}\FunctionTok{sapply}\NormalTok{(iris, is.numeric))],}
\NormalTok{       mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
##     5.843333     3.057333     3.758000     1.199333
\end{verbatim}

Die \texttt{sapply}-Funktion macht also im Prinzip nicht viel anderes, als unsere \texttt{for}-Schleifen.

\hypertarget{aufgabe-9}{%
\subsection{Aufgabe}\label{aufgabe-9}}

Baue die oben mit \texttt{sapply} implementierte Mittlung mit \texttt{for}-Schleifen nach.
Dabei soll erst überprüft werden, ob eine Spalte numerische Inhalte hat, wenn dem so ist soll der Mittelwert dieser Spalte berechnet werden.
Verpacke deine Lösung in eine Funktion, die den spaltenweisen Mittelwert zurückgibt.

Überlege dir insbesondere, ob Du den Output-Vektor allozieren kannst und was ein sinnvolles Format dafür wäre.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_col\_mean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(df)\{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\FunctionTok{ncol}\NormalTok{(df))}
  \FunctionTok{names}\NormalTok{(out) }\OtherTok{\textless{}{-}} \FunctionTok{names}\NormalTok{(df)}
  \ControlFlowTok{for}\NormalTok{(col }\ControlFlowTok{in} \FunctionTok{names}\NormalTok{(df))\{}
    \ControlFlowTok{if}\NormalTok{(}\FunctionTok{is.numeric}\NormalTok{(df[[col]]))\{}
\NormalTok{      out[col] }\OtherTok{\textless{}{-}} \FunctionTok{mean}\NormalTok{(df[[col]])}
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(out)}
\NormalTok{\}}
\FunctionTok{my\_col\_mean}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##     5.843333     3.057333     3.758000     1.199333           NA
\end{verbatim}

\hypertarget{purrrmap}{%
\section{\texorpdfstring{\texttt{purrr::map}}{purrr::map}}\label{purrrmap}}

Eine Alternative zu den \texttt{*apply}-Funktionen ist die \texttt{map}-Familie aus dem \texttt{purrr}-Paket. Im Prinzip sind die identisch zu den \texttt{*apply}-Funktionen, der große Unterschied ist, dass sie spezialisierter sind als erstere.

Diese Eigenschaft ist auch der einzige wirkliche Grund dafür, die functional-Iteratoren den Schleifen vorzuziehen. Code, der so spezifisch für ein Problem wie möglich ist, ist einfach schöner weil schneller verständlich.

Die grundlegende Funktion aus der \texttt{map}-Familie ist das einfache \texttt{map}, das \texttt{lapply}-Analogon. \texttt{map} nimmt also eine Liste oder einen Vektor und eine Funktion als Input und gibt eine Liste zurück:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, sqrt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051
## 
## [[4]]
## [1] 2
## 
## [[5]]
## [1] 2.236068
## 
## [[6]]
## [1] 2.44949
## 
## [[7]]
## [1] 2.645751
## 
## [[8]]
## [1] 2.828427
## 
## [[9]]
## [1] 3
## 
## [[10]]
## [1] 3.162278
\end{verbatim}

Alternativ kann mit der sogenannten Funktionsschreibweise auch ein Ausdruck formuliert werden, der für jeden iterierten Wert ausgeführt werden soll:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\FunctionTok{sqrt}\NormalTok{(.))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051
## 
## [[4]]
## [1] 2
## 
## [[5]]
## [1] 2.236068
## 
## [[6]]
## [1] 2.44949
## 
## [[7]]
## [1] 2.645751
## 
## [[8]]
## [1] 2.828427
## 
## [[9]]
## [1] 3
## 
## [[10]]
## [1] 3.162278
\end{verbatim}

Der besondere Vorteil dieser Funktionen gegenüber den \texttt{*apply}-Funktionen, ist dass diese Gruppe von Funktionen ermöglicht, den erwarteten Output einer Iteration klar lesbar zu definieren.

Beispielsweise kann mit \texttt{map\_dbl}, \texttt{map\_lgl} und \texttt{map\_chr} klar festgelegt werden, dass 1. ein \texttt{atomic}-Vektor ausgegeben wird, der 2. einen klaren Datentyp hat:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map\_dbl}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\NormalTok{.}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   1   4   9  16  25  36  49  64  81 100
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map\_lgl}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\NormalTok{.}\SpecialCharTok{\%\%}\DecValTok{2}\SpecialCharTok{==}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map\_chr}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\NormalTok{letters[.])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}

Und, noch praktischer, auch für komplexere Datentypen gibt es Wrapper. So können wir zum Beispiel mit \texttt{map\_dfr} und \texttt{map\_dfc} \texttt{tibble}s erzeugen lassen, die dann aus zeilenweise (\texttt{df}\emph{\texttt{r}} für rows) und spaltenweise (\texttt{df}\emph{\texttt{c}} für columns) zusammengefügten Ergebnissen bestehen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map\_dfr}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\FunctionTok{tibble}\NormalTok{(}\AttributeTok{i =}\NormalTok{ .,}
                      \AttributeTok{x =} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 10 x 2
##        i     x
##    <int> <int>
##  1     1    10
##  2     2     7
##  3     3     3
##  4     4     5
##  5     5     3
##  6     6     7
##  7     7     5
##  8     8    10
##  9     9     1
## 10    10     3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map\_dfc}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\SpecialCharTok{\textasciitilde{}}\FunctionTok{c}\NormalTok{(}\FunctionTok{sample}\NormalTok{(.}\SpecialCharTok{:}\NormalTok{(.}\SpecialCharTok{+}\DecValTok{10}\NormalTok{),}\DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## New names:
## * NA -> ...1
## * NA -> ...2
## * NA -> ...3
## * NA -> ...4
## * NA -> ...5
## * ...
\end{verbatim}

\begin{verbatim}
## # A tibble: 1 x 10
##    ...1  ...2  ...3  ...4  ...5  ...6  ...7  ...8  ...9 ...10
##   <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>
## 1     5     8     3     4    15     9    11    15    13    10
\end{verbatim}

\hypertarget{exkurs-iteratoren-vergleich-und-microbenchmarking}{%
\section{Exkurs: Iteratoren-Vergleich und Microbenchmarking}\label{exkurs-iteratoren-vergleich-und-microbenchmarking}}

Man liest manchmal, dass loops in R wegen geringerer Geschwindigkeit in jedem Fall vermieden werden sollten. Das stimmt aber nicht wirklich, wenn man für seine \texttt{for}-Schleifen alloziert.

Um das zu zeigen vergleichen wir mit der folgenden Funktion \texttt{for} ohne Allokation, for mit Allokation, \texttt{sapply} und \texttt{map\_dbl}. Um die Laufzeiten zu vergleichen, nutzen wir die \texttt{bench::mark}- und \texttt{bench::press}-Funktion, sehr akkurate Funktion um Microbenchmarking durchzuführen.
Microbenchmarking heißt hier nichts anders, als dass wir die möglichen Implementationen alle unter denselben Bedingungen sehr oft ausführen und die Ausführungszeiten notieren, um eine Idee von der Effizienz dieser zu erlangen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_function }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) x}\SpecialCharTok{\^{}}\DecValTok{2}


\NormalTok{results }\OtherTok{\textless{}{-}}\NormalTok{ bench}\SpecialCharTok{::}\FunctionTok{press}\NormalTok{(}\AttributeTok{n =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,}
\NormalTok{                        \{}
\NormalTok{                          to\_do }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10} \SpecialCharTok{\^{}}\NormalTok{ n}
\NormalTok{                          bench}\SpecialCharTok{::}\FunctionTok{mark}\NormalTok{(}
                            \AttributeTok{min\_iterations =} \DecValTok{100}\NormalTok{,}
                            
                            \AttributeTok{for\_no\_alloc =}\NormalTok{ \{}
\NormalTok{                              res }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{()}
                              \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in}\NormalTok{ to\_do) \{}
\NormalTok{                                res }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(res, }\FunctionTok{my\_function}\NormalTok{(j))}
\NormalTok{                              \}}
\NormalTok{                              res}
\NormalTok{                            \},}
                            
                            \AttributeTok{for\_alloc =}\NormalTok{ \{}
\NormalTok{                              res }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{length}\NormalTok{(to\_do))}
                              \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in}\NormalTok{ to\_do) \{}
\NormalTok{                                res[j] }\OtherTok{\textless{}{-}} \FunctionTok{my\_function}\NormalTok{(j)}
\NormalTok{                              \}}
\NormalTok{                              res}
\NormalTok{                            \},}
                            
                            \AttributeTok{while\_alloc =}\NormalTok{ \{}
\NormalTok{                              res }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{length}\NormalTok{(to\_do))}
\NormalTok{                              j }\OtherTok{\textless{}{-}} \DecValTok{1}
                              \ControlFlowTok{while}\NormalTok{(j }\SpecialCharTok{\textless{}} \FunctionTok{length}\NormalTok{(to\_do)) \{}
\NormalTok{                                res[to\_do[j]] }\OtherTok{\textless{}{-}} \FunctionTok{my\_function}\NormalTok{(to\_do[j])}
\NormalTok{                                j }\OtherTok{\textless{}{-}}\NormalTok{ j }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{                              \}}
\NormalTok{                              res}
\NormalTok{                            \},}
                            
                            \AttributeTok{sapply =}\NormalTok{ \{}
\NormalTok{                              res }\OtherTok{\textless{}{-}} \FunctionTok{sapply}\NormalTok{(to\_do, my\_function)}
\NormalTok{                            \},}
                            
                            \AttributeTok{map\_dbl =}\NormalTok{ \{}
\NormalTok{                              res }\OtherTok{\textless{}{-}} \FunctionTok{map\_dbl}\NormalTok{(to\_do, my\_function)}
\NormalTok{                            \}}
\NormalTok{                          )}
\NormalTok{                        \})}
\end{Highlighting}
\end{Shaded}

Die Ergebnisse dieses Testlaufs sehen so aus:

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-73-1.pdf}

Dabei stellen die Linien die Median-Verläufe der jeweiligen Aufrufe dar. Vorsicht: Die Achsen sind logarithmisch skaliert. Ohne diese Skalierung sehen die Ergebnisse so aus:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pmap\_dfr}\NormalTok{(}\FunctionTok{list}\NormalTok{(sim\_data}\SpecialCharTok{$}\NormalTok{time,}
              \FunctionTok{names}\NormalTok{(sim\_data}\SpecialCharTok{$}\NormalTok{expression),}
\NormalTok{              sim\_data}\SpecialCharTok{$}\NormalTok{n),}
         \SpecialCharTok{\textasciitilde{}}\FunctionTok{tibble}\NormalTok{(}\AttributeTok{times =} \FunctionTok{as.numeric}\NormalTok{(..}\DecValTok{1}\NormalTok{),}
                 \AttributeTok{iterator =}\NormalTok{ ..}\DecValTok{2}\NormalTok{,}
                 \AttributeTok{reps =} \DecValTok{10}\SpecialCharTok{\^{}}\NormalTok{..}\DecValTok{3}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ reps,}
             \AttributeTok{y =}\NormalTok{ times,}
             \AttributeTok{color =}\NormalTok{ iterator)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{1}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{stat\_summary}\NormalTok{(}\AttributeTok{geom=}\StringTok{\textquotesingle{}line\textquotesingle{}}\NormalTok{,}
               \AttributeTok{fun =}\NormalTok{ median) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{y =} \StringTok{\textquotesingle{}Zeit [s]\textquotesingle{}}\NormalTok{,}
       \AttributeTok{x =} \StringTok{\textquotesingle{}Iterierte Werte\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_color\_brewer}\NormalTok{(}\AttributeTok{palette =} \StringTok{\textquotesingle{}Dark2\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-74-1.pdf}

\hypertarget{aufgabe-10}{%
\subsection{Aufgabe}\label{aufgabe-10}}

Benutzt \texttt{bench::mark} um die folgenden drei Mittelwerts-Funktionen zu vergleichen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_for\_mean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in}\NormalTok{ x)\{}
\NormalTok{    out }\OtherTok{\textless{}{-}}\NormalTok{ out }\SpecialCharTok{+}\NormalTok{ i}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(out}\SpecialCharTok{/}\FunctionTok{length}\NormalTok{(x))}
\NormalTok{\}}

\NormalTok{my\_manual\_mean }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{sum}\NormalTok{(x)}\SpecialCharTok{/}\FunctionTok{length}\NormalTok{(x))}
\NormalTok{\}}

\FunctionTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{10000}\NormalTok{)}
\NormalTok{bmark }\OtherTok{\textless{}{-}}\NormalTok{ bench}\SpecialCharTok{::}\FunctionTok{mark}\NormalTok{(}\AttributeTok{mean =} \FunctionTok{mean}\NormalTok{(x),}
             \AttributeTok{for\_mean =} \FunctionTok{my\_for\_mean}\NormalTok{(x),}
             \AttributeTok{man\_mean =} \FunctionTok{my\_manual\_mean}\NormalTok{(x),}
            \AttributeTok{iterations =} \DecValTok{10000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Übrigens gibt es noch eine sehr nette Funktion, die man im Kontext von \texttt{bench::mark} nochmal erwähnen sollte:

Mit \texttt{autoplot(type\ =\ \textquotesingle{}violin\textquotesingle{})} lassen sich die Ergebnisse eines Mikrobenchmarks ganz nett darstellen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(bench)}
\NormalTok{bmark }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{autoplot}\NormalTok{(}\AttributeTok{type =} \StringTok{\textquotesingle{}violin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-78-1.pdf}

\hypertarget{eigene-functionals}{%
\section{Eigene Functionals}\label{eigene-functionals}}

Warum Functionals neben den Iteratoren für uns praktisch sind, wird am Simulations-Beispiel klar.

Wenn wir eine Funktion schreiben wollen, die zum Beispiel für einen t-Test das Ausschöpfen des Alpha-Niveaus bei verschiedenen Verteilungen überprüft, könnten wir wie bisher für eine Untermenge der Möglichkeiten mit if-else die richtige Funktion auswählen.
Schöner wäre es aber doch, wenn wir eine Simulationsfunktion hätten, die einfach eine Funktion als Objekt nimmt und die Ergebnisse zurückgibt.

Dafür müssen wir erstmal verstehen, warum der folgende Aufruf funktioniert:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rnd\_fct }\OtherTok{\textless{}{-}}\NormalTok{ rnorm}

\FunctionTok{rnd\_fct}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] -0.4199126  0.2312317  0.4539680  0.2489447  1.0210670 -1.3311690
##  [7]  1.5289611  0.1749426 -0.8485907 -1.0582308
\end{verbatim}

Wir haben in \texttt{rnd\_fct} einen Verweis auf \texttt{rnorm} abgelegt und können den Namen des Verweises jetzt äquivalent zum Inhalt des Ziels, also ganz einfach wie die ursprüngliche Funktion verwenden.

Das funktioniert aus ähnlichen Gründen, aus denen unsere Listen mit Verweisen kleiner als erwartet waren. Da wir den Inhalt nicht verändert haben, spart sich R den Aufwand die Funktion zu kopieren und legt einfach einen zweiten Verweis auf die \texttt{rnorm}-Funktion an, inklusive \texttt{body} und \texttt{formals}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{body}\NormalTok{(rnorm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## .Call(C_rnorm, n, mean, sd)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{body}\NormalTok{(rnd\_fct)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## .Call(C_rnorm, n, mean, sd)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{formals}\NormalTok{(rnorm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $n
## 
## 
## $mean
## [1] 0
## 
## $sd
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{formals}\NormalTok{(rnd\_fct)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $n
## 
## 
## $mean
## [1] 0
## 
## $sd
## [1] 1
\end{verbatim}

Mit anderen Worten können wir einen Verweis auf ein Funktions-Objekt wie die eigentliche Funktion verwenden. Diesen Umstand können wir ausnutzen, wenn wir unsere Simulationsfunktion schreiben, indem wir einfach ein Argument vorsehen, dass als Funktion benutzt werden kann.

So eine Funktion könnte so aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generate\_values }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{rnd\_fct =}\NormalTok{ rnorm,}
                            \AttributeTok{n =} \DecValTok{1000}\NormalTok{)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rnd\_fct}\NormalTok{(n))}
\NormalTok{\}}

\FunctionTok{generate\_values}\NormalTok{(}\AttributeTok{n =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  0.2994693  0.5303306  2.3644090 -1.5828983  0.3834167 -0.8116823
##  [7] -1.1964809 -0.6136671  1.2368626  0.5172003
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{generate\_values}\NormalTok{(runif, }\AttributeTok{n =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0.44395272 0.30926817 0.13344473 0.58773504 0.47318257 0.61197434
##  [7] 0.37293941 0.91837751 0.74896328 0.07670441
\end{verbatim}

Und schon ist unser erster Functional fertig.

\hypertarget{aufgabe-11}{%
\subsection{Aufgabe}\label{aufgabe-11}}

Erstelle einen functional \texttt{summarise\_for\_me}, der einen Vektor als Argument x und eine Funktion als Argument \texttt{agg\_fn} erwartet, und die Ihr dazu nutzen könnt, mit demselben Stichwort NA-bereinigt Summe, Mittelwert, Median
und SD des Vektors \texttt{c(10,\ NA,\ 21,\ 25,\ 13)} zu berechnen.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summarise\_for\_me }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, agg\_fn)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{agg\_fn}\NormalTok{(x, }\AttributeTok{na.rm =}\NormalTok{ T))}
\NormalTok{\}}

\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{13}\NormalTok{)}
\FunctionTok{summarise\_for\_me}\NormalTok{(x, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 17.25
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 69
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, median)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, sd)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.946222
\end{verbatim}

\hypertarget{argumente-durchreichen}{%
\section{Argumente durchreichen}\label{argumente-durchreichen}}

Unsere schöne Funktion wird offensichtlich problematisch, wenn wir zum Beispiel \texttt{rf} übergeben:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{generate\_values}\NormalTok{(rf, }\AttributeTok{n =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in rnd_fct(n): argument "df1" is missing, with no default
\end{verbatim}

Dafür gibt es in R den Platzhalter \texttt{...}, dem Ihr auch schon an anderer Stelle begegnet sein könntet. \texttt{...} heißt nichts anderes als dass mehr Argumente möglich sind, bei denen wir noch nicht so ganz sicher sind, welche es sein werden.

Benutzen können wir das wie jedes andere Argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generate\_values }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{rnd\_fct =}\NormalTok{ rnorm,}
                            \AttributeTok{n =} \DecValTok{1000}\NormalTok{,}
\NormalTok{                            ...)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rnd\_fct}\NormalTok{(n, ...))}
\NormalTok{\}}

\FunctionTok{generate\_values}\NormalTok{(rf, }\AttributeTok{n =} \DecValTok{100}\NormalTok{, }\AttributeTok{df1 =} \DecValTok{5}\NormalTok{, }\AttributeTok{df2 =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1]  1.30800244  0.34386902  1.07185386  1.26556593  1.07752607  2.03497546
##   [7]  0.63611837  0.87353987  1.03485287  0.81601814  1.02639860  0.53705763
##  [13]  0.31405869  0.52439110  1.39648091  1.06064416  0.46664706  0.27070874
##  [19]  2.25204656  0.86366757  1.15693767  1.81259878  0.56410316  0.94787277
##  [25]  3.89529621  0.37557481  1.92586101  0.42849312  1.49773976  0.05813357
##  [31]  0.44438564  0.14525814  2.36696864  1.66339698  0.53827284  1.65650546
##  [37]  0.46055553  1.60033949  0.30694711  1.85127786  1.48217075  2.62585139
##  [43]  2.14504737  0.81919515  1.38374697  0.89745419  0.37185526  1.13406191
##  [49]  1.31479498  0.65300786  0.80247351  1.80981147  0.32507006  1.55078471
##  [55]  1.18369100  0.08447330  1.91984029  0.13914696  0.79177535  0.94549312
##  [61]  0.93354001  0.28173625  1.45672514  0.60835450  0.91438839  0.75916434
##  [67]  1.97458061  0.17009112  1.49389432  2.16806557  1.61570079  0.33946545
##  [73]  1.30805728  1.48765000  0.41400625  0.98439720  2.91565515  1.18407534
##  [79]  0.26514127  0.71282182  0.73094521  0.94654944  1.06797966 12.72549312
##  [85]  2.87107955  1.15050343  0.27958205  0.55015957  0.47310973  0.89918620
##  [91]  1.87930474  1.79708365  2.26899240  1.19920258  1.43975652  0.47004905
##  [97]  1.47975343  1.80849062  2.76730517  1.20793446
\end{verbatim}

Sollten wir in dieser Liste noch für einen Sonderfall testen wollen (zum Beispiel um Sonderbehandlungen durchzuführen), können wir mit \texttt{hasArg} auf ein Argument testen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generate\_values }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{rnd\_fct =}\NormalTok{ rnorm,}
                            \AttributeTok{n =} \DecValTok{1000}\NormalTok{,}
\NormalTok{                            ...)\{}
  \ControlFlowTok{if}\NormalTok{(}\FunctionTok{hasArg}\NormalTok{(df2))\{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}more than one df}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rnd\_fct}\NormalTok{(n, ...))}
\NormalTok{\}}

\FunctionTok{generate\_values}\NormalTok{(rf, }\AttributeTok{n =} \DecValTok{10}\NormalTok{, }\AttributeTok{df1 =} \DecValTok{5}\NormalTok{, }\AttributeTok{df2 =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## more than one df
\end{verbatim}

\begin{verbatim}
##  [1] 1.7191709 0.3844587 0.3358765 0.4924094 2.3220831 0.8904054 1.5374226
##  [8] 0.3068908 1.7804266 0.1659158
\end{verbatim}

Damit könnten wir auch eigene Argumente definieren, wenn wir die Funktionsdefinition übersichtlich halten wollen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generate\_values }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{rnd\_fct =}\NormalTok{ rnorm,}
                            \AttributeTok{n =} \DecValTok{1000}\NormalTok{,}
\NormalTok{                            ...)\{}
  \ControlFlowTok{if}\NormalTok{(}\FunctionTok{hasArg}\NormalTok{(skew))\{}
\NormalTok{    args }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(...)}
\NormalTok{    skew }\OtherTok{\textless{}{-}}\NormalTok{ args}\SpecialCharTok{$}\NormalTok{skew}
\NormalTok{    args }\OtherTok{\textless{}{-}}\NormalTok{ args[}\FunctionTok{names}\NormalTok{(args) }\SpecialCharTok{!=} \StringTok{\textquotesingle{}skew\textquotesingle{}}\NormalTok{]}
\NormalTok{    args}\SpecialCharTok{$}\NormalTok{n }\OtherTok{\textless{}{-}}\NormalTok{ n}
\NormalTok{    out }\OtherTok{\textless{}{-}} \FunctionTok{do.call}\NormalTok{(rnd\_fct, args)}
    \FunctionTok{return}\NormalTok{(out }\SpecialCharTok{+}\NormalTok{ skew }\SpecialCharTok{*}\NormalTok{ out}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rnd\_fct}\NormalTok{(n, ...))}
\NormalTok{\}}

\FunctionTok{generate\_values}\NormalTok{(rf, }\AttributeTok{n =} \DecValTok{10}\NormalTok{, }\AttributeTok{df1 =} \DecValTok{5}\NormalTok{, }\AttributeTok{df2 =} \DecValTok{10}\NormalTok{, }\AttributeTok{skew =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1.4748042 2.4036888 0.3793993 1.9490523 4.1082832 1.2057001 0.5293067
##  [8] 0.8127482 0.2072046 4.8083358
\end{verbatim}

So haben wir eine allgemeine Funktion geschrieben, die zum einen flexibel Daten mit übergebenen Funktionen generiert und zum anderen im Falle eines gesetzten Arguments \texttt{skew} dieses aus den Argumenten nimmt und das Ergebnis des Funktionsarguments mit den restlichen \texttt{...}-Argumenten mit dem Skew transformiert.

Auch nochmal zu betonen ist, dass wir den \texttt{...}-Operator sowohl nutzen können, um die Argumente durchzureichen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{do\_something }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(.fn, ...)\{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{.fn}\NormalTok{(...))}
\NormalTok{\}}
\FunctionTok{do\_something}\NormalTok{(mean, }\AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\AttributeTok{trim =}\NormalTok{ .}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.5
\end{verbatim}

als auch um eine Liste zu erstellen, die wir dann mit \texttt{do.call} als Argumentliste übergeben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{do\_something }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(.fn, ...)\{}
\NormalTok{  args }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(...)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{do.call}\NormalTok{(.fn, args))}
\NormalTok{\}}
\FunctionTok{do\_something}\NormalTok{(mean, }\AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\AttributeTok{trim =}\NormalTok{ .}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.5
\end{verbatim}

Letztere Methode ist dann praktisch, wenn wir entweder die Argumente ergänzen wollen, oder wie im Fall oben, nur Teile des Calls an eine Funktion weiterreichen wollen.

Da diese ``impliziten'' Argumente aber für \texttt{formals} und Autocomplete nicht zugänglich sind, außerdem das schreiben eines Arguments als expliziten Teil der Funktion einfacher ist, sollte außer bei sehr komplexen (z.B. grafischen) Funktionen auf diese Art der Argumente eher verzichtet werden.

Wir könnten die Verteilungs-Funktion mit Skew von oben ja auch (viel übersichtlicher und mit Standardwert) wie folgt schreiben:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generate\_values }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(}\AttributeTok{rnd\_fct =}\NormalTok{ rnorm,}
                            \AttributeTok{n =} \DecValTok{1000}\NormalTok{,}
                            \AttributeTok{skew =} \DecValTok{0}\NormalTok{,}
\NormalTok{                            ...)\{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{rnd\_fct}\NormalTok{(n, ...)}
  \FunctionTok{return}\NormalTok{(out }\SpecialCharTok{+}\NormalTok{ skew }\SpecialCharTok{*}\NormalTok{ out}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}

\FunctionTok{generate\_values}\NormalTok{(rf, }\AttributeTok{n =} \DecValTok{10}\NormalTok{, }\AttributeTok{df1 =} \DecValTok{5}\NormalTok{, }\AttributeTok{df2 =} \DecValTok{10}\NormalTok{, }\AttributeTok{skew =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 34.6888898  5.5226003  5.1995615 22.6796614 23.0399780  0.5764265
##  [7]  2.2664878 19.1496233  4.9516273  0.4087788
\end{verbatim}

\hypertarget{aufgabe-12}{%
\subsection{Aufgabe}\label{aufgabe-12}}

Ergänze den functional \texttt{summarise\_for\_me} um einen \texttt{...}-Operator als Argument.
Benutze diesen, um Argumente an die Funktionen weiterzugeben.

Baue außerdem eine Ausnahmebedingung in die Funktion ein, die falls das Argument \texttt{scale} auf TRUE gesetzt ist, die Daten vor der Aggregation z-transformiert.\footnote{Das funktioniert ganz einfach mit der \texttt{scale}-Funktion.}

Stelle außerdem sicher, dass die Funktion unabhängig von der Eingabe des Nutzers \texttt{na.rm} auf \texttt{TRUE} setzt.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summarise\_for\_me }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, agg\_fn, ...)\{}
\NormalTok{  args }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(...)}
  \ControlFlowTok{if}\NormalTok{(}\FunctionTok{hasArg}\NormalTok{(scale))\{}
    \ControlFlowTok{if}\NormalTok{(args}\SpecialCharTok{$}\NormalTok{scale)\{}
\NormalTok{      x }\OtherTok{\textless{}{-}} \FunctionTok{scale}\NormalTok{(x)}
\NormalTok{      args }\OtherTok{\textless{}{-}}\NormalTok{ args[}\SpecialCharTok{!}\NormalTok{(}\FunctionTok{names}\NormalTok{(args) }\SpecialCharTok{==} \StringTok{\textquotesingle{}scale\textquotesingle{}}\NormalTok{)]}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  args }\OtherTok{\textless{}{-}}\NormalTok{ args[}\SpecialCharTok{!}\NormalTok{(}\FunctionTok{names}\NormalTok{(args) }\SpecialCharTok{==} \StringTok{\textquotesingle{}na.rm\textquotesingle{}}\NormalTok{)]}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{agg\_fn}\NormalTok{(x, }\AttributeTok{na.rm =}\NormalTok{ T))}
\NormalTok{\}}

\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{13}\NormalTok{)}
\FunctionTok{summarise\_for\_me}\NormalTok{(x, mean, }\AttributeTok{scale =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.775558e-17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, sum, }\AttributeTok{scale =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.110223e-16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, median, }\AttributeTok{scale =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.03599079
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, sd, }\AttributeTok{scale =}\NormalTok{ F)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.946222
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise\_for\_me}\NormalTok{(x, sd, }\AttributeTok{scale =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\hypertarget{simulations--und-programmieruxfcbungen-in-r}{%
\chapter{Simulations- und Programmierübungen in R}\label{simulations--und-programmieruxfcbungen-in-r}}

Im Folgenden werden keine neuen Konzepte eingeführt, zum Üben der bisher eingeführten Konzepte werden aber eine Reihe von Aufgaben gestellt, die Schritt für Schritt mit statistischen Beispielen zu ersten eigenen und zunehmend komplexen Simulationen führen sollen.
Zu jeder Aufgabe wird auch eine Musterlösung angeboten, wie immer ist diese aber zum Einen nicht die einzig mögliche Lösung und zum Anderen bitte erst zu konsultieren, wenn eine eigene Lösung versucht wurde.
Der Lernfortschritt durch eigenes Programmieren (und Fehler machen) ist wesentlich größer als durch das einfache Lesen fertiger Skripte.

\hypertarget{pascalsches-dreieck}{%
\section{Pascalsches Dreieck}\label{pascalsches-dreieck}}

Das Ziel soll sein, eine Funktion namens \texttt{binom\_mat} zu erstellen, die für eine gegebene Zahl n das Pascalsche Dreieck bis zur gegebenen Größe zurückgibt.
Dieses Dreieck soll erstmal als Matrix zurückgegeben werden, die für die Zahl 5 zum Beispiel so aussehen könnte:

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    0    0    0    0
## [2,]    1    1    0    0    0
## [3,]    1    2    1    0    0
## [4,]    1    3    3    1    0
## [5,]    1    4    6    4    1
\end{verbatim}

Die erste Spalte der Matrix soll also die ``obere linke Flanke'' des Dreiecks repräsentieren.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binom\_mat }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(z)\{                    }\CommentTok{\# (1)}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{0}\NormalTok{,z,z)                       }\CommentTok{\# (2)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(z))\{                          }\CommentTok{\# (3)}
\NormalTok{    mat[i,}\DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{  \}}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,z))\{                        }\CommentTok{\# (4)}
    \ControlFlowTok{for}\NormalTok{(j }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,i))\{                      }\CommentTok{\# (5)}
\NormalTok{      mat[i,j] }\OtherTok{\textless{}{-}}\NormalTok{ mat[i}\DecValTok{{-}1}\NormalTok{,j}\DecValTok{{-}1}\NormalTok{] }\SpecialCharTok{+}\NormalTok{ mat[i}\DecValTok{{-}1}\NormalTok{,j]  }\CommentTok{\# (6)}
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(mat)                                }\CommentTok{\# (7)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Erläuterungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Die Matrix soll am Ende z Zeilen haben. Allerdings werden die Zeilen und Spalten einer Matrix beginnend mit 1 durchnummeriert, so dass die Zeilennummer nicht das n der Binomialkoeffizienten ist. Vielmehr stehen die Bionomialkoeffizienten \(n \choose k\) am Ende in der Zeile mit der Nummer n+1 und der Spalte mit der Nummer k+1.
\item
  Hier wird eine Matrix erzeugt, die den Namen mat bekommt. Die Matrix wird zunächst mit Nullen gefüllt. Sie soll z Zeilen und z Spalten haben.
\item
  Die linke Spalte der Matrix wird mit Einsen gefüllt. Hier ist zu bemerken, dass die Elemente einer Matrix mit Zeilen- und Spaltennummer in eckigen Klammern angesprochen werden.
\item
  Hier folgen verschachtelte Schleifen. In der äußeren Schleife werden die Zeilen der Matrix angesprochen, die der Reihe nach mit den richtigen Zahlen gefüllt werden sollen. Die erste Zeile der Matrix hat schon die Endgestalt, daher beginnt die Schleife mit i=2.
\item
  Hier kommt die innere Schleife; die Zeile mit der Nummer i ist erreicht, die vorherigen Zeilen sind schon richtig aufgefüllt worden. Die Elemente in dieser Zeile ergeben sich dadurch, dass man die Zahlen links darüber und direkt darüber addiert. Die erste Zahl 1 der Zeile wurde vorher schon eingefüllt, daher fängt die Schleife mit j=2 an; außerdem sind die Zahlen am Ende alle 0 (sofern sie außerhalb des Dreiecks liegen), daher geht die Schleife nur bis j=i (i ist an dieser Stelle eine feste Zahl).
\item
  Hier werden -- wie gerade beschrieben -- die Zahlen der i-ten Zeile eingefügt.
\item
  Die Matrix ist jetzt fertig ausgefüllt und wird an dieser Stelle zurückgegeben.
\end{enumerate}

Für manche Anwendungen wollen wir vielleicht eine Liste, keine Matrix als Output haben.

Schreibe deswegen eine Funktion \texttt{binom\_list}, die eine Liste von Vektoren zurückgibt.

Verpacke dann beide Funktionen in eine \texttt{binom\_pascal}-Funktion, in der mit einem optionalen Argument das Output-Format für das Pascalsche Dreieck angibt.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binom\_list }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(z) \{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{()}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(z)) \{}
\NormalTok{    out[[i]] }\OtherTok{\textless{}{-}} \DecValTok{1}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{) \{}
\NormalTok{      out[[i]][j] }\OtherTok{\textless{}{-}}
\NormalTok{        out[[i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{]][j }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{] }\SpecialCharTok{+} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(out[[i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{]][j]), }
                                     \DecValTok{0}\NormalTok{, }
\NormalTok{                                     out[[i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{]][j])}
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(out)}
\NormalTok{\}}

\FunctionTok{binom\_list}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1 1
## 
## [[3]]
## [1] 1 2 1
## 
## [[4]]
## [1] 1 3 3 1
## 
## [[5]]
## [1] 1 4 6 4 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binom\_pascal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(z, }\AttributeTok{format =} \StringTok{\textquotesingle{}m\textquotesingle{}}\NormalTok{)\{}
  \ControlFlowTok{if}\NormalTok{(format }\SpecialCharTok{!=} \StringTok{\textquotesingle{}m\textquotesingle{}}\NormalTok{)\{}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{binom\_list}\NormalTok{(z))}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{binom\_mat}\NormalTok{(z))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Erweitere deine Listenfunktion so, dass die zurückgegebene Liste die Klasse \texttt{pascal} hat und die Anzahl der Zeilen des Dreiecks im \texttt{n}-Attribut abgelegt wird.

Schreibe nun eine Erweiterung des \texttt{print}-Befehls, indem du eine Funktion \texttt{print.pascal} definierst, die die Argumente \texttt{x} und den \texttt{...}-Operator erwartet.

Mit diesem Namen legst Du fest, dass die \texttt{pascal}-Klasse mit genau dieser Funktion geprintet werden soll, sobald also ein Objekt diese Klasse hat, wird diese Printfunktion aufgerufen.

Der Output soll dabei so aussehen:

\begin{verbatim}
##     1
##    1 1
##   1 2 1
##  1 3 3 1
## 1 4 6 4 1
\end{verbatim}

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binom\_list }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(z) \{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{()}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(z)) \{}
\NormalTok{    out[[i]] }\OtherTok{\textless{}{-}} \DecValTok{1}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{) }\SpecialCharTok{+} \DecValTok{1}\NormalTok{) \{}
\NormalTok{      out[[i]][j] }\OtherTok{\textless{}{-}}
\NormalTok{        out[[i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{]][j }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{] }\SpecialCharTok{+} \FunctionTok{ifelse}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(out[[i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{]][j]), }
                                     \DecValTok{0}\NormalTok{, }
\NormalTok{                                     out[[i }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{]][j])}
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{attributes}\NormalTok{(out)}\SpecialCharTok{$}\NormalTok{class }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}pascal\textquotesingle{}}
  \FunctionTok{attributes}\NormalTok{(out)}\SpecialCharTok{$}\NormalTok{n }\OtherTok{\textless{}{-}}\NormalTok{ z}
  \FunctionTok{return}\NormalTok{(out)}
\NormalTok{\}}

\DocumentationTok{\#\# für einfache Zahlen können wir die print{-}Funktion so schreiben:}
\NormalTok{print.pascal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,...)\{}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{attributes}\NormalTok{(x)[[}\StringTok{\textquotesingle{}n\textquotesingle{}}\NormalTok{]]}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(n))\{}
    \FunctionTok{cat}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, n}\SpecialCharTok{{-}}\NormalTok{i), }\AttributeTok{sep =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
    \FunctionTok{cat}\NormalTok{(x[[i]])}
    \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\DocumentationTok{\#\# funktioniert:}
\FunctionTok{binom\_list}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     1
##    1 1
##   1 2 1
##  1 3 3 1
## 1 4 6 4 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# geht bei mehr digits aber kaputt:}
\FunctionTok{binom\_list}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       1
##      1 1
##     1 2 1
##    1 3 3 1
##   1 4 6 4 1
##  1 5 10 10 5 1
## 1 6 15 20 15 6 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# mit einer Verallgemeinerung der eingefügten Leerzeichen klappt das aber auch:}
\NormalTok{print.pascal }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,...)\{}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{attr}\NormalTok{(x, }\StringTok{\textquotesingle{}n\textquotesingle{}}\NormalTok{)}
\NormalTok{  nsp }\OtherTok{\textless{}{-}} \FunctionTok{nchar}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(}\FunctionTok{max}\NormalTok{(x[[n]]))) }\CommentTok{\# guck wie viele Stellen die längste Zahl hat}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(n))\{}
\NormalTok{    dummy }\OtherTok{\textless{}{-}} \FunctionTok{str\_pad}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(x[[i]]), }\CommentTok{\# ergänze die Zahl als character auf die größte Länge}
                     \AttributeTok{side =} \StringTok{\textquotesingle{}left\textquotesingle{}}\NormalTok{, }
                     \AttributeTok{width =}\NormalTok{ nsp)}
    \FunctionTok{cat}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, nsp }\SpecialCharTok{*}\NormalTok{ (n}\SpecialCharTok{{-}}\NormalTok{i)), }\AttributeTok{sep =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
    \FunctionTok{cat}\NormalTok{(dummy, }\AttributeTok{sep =} \FunctionTok{paste0}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, nsp), }\AttributeTok{collapse =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}
    \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}

\FunctionTok{binom\_list}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                              1
##                           1     1
##                        1     2     1
##                     1     3     3     1
##                  1     4     6     4     1
##               1     5    10    10     5     1
##            1     6    15    20    15     6     1
##         1     7    21    35    35    21     7     1
##      1     8    28    56    70    56    28     8     1
##   1     9    36    84   126   126    84    36     9     1
\end{verbatim}

Als letztes wollen wir die Funktion nur noch praktisch nutzen.
Dafür müssen wir noch eine Funktion \texttt{binom\_coeff} schreiben, die für gegebenes n und k den Wert des Binominialkoeffizienten ausgibt.

Überlege Dir dazu, ob Du lieber \texttt{binom\_mat} oder \texttt{binom\_list} benutzen möchtest.
Mit \texttt{choose(n,k)} kannst Du überprüfen, ob die in R angelegte Funktion für den Binomialkoeffizienten auf dieselbe Lösung kommt.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binom\_coeff }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n,k)\{}
  \ControlFlowTok{if}\NormalTok{(n}\SpecialCharTok{==}\DecValTok{0}\NormalTok{)\{                               }\CommentTok{\# (1)}
    \ControlFlowTok{if}\NormalTok{(k}\SpecialCharTok{==}\DecValTok{0}\NormalTok{)\{}\FunctionTok{return}\NormalTok{(}\DecValTok{1}\NormalTok{)\} }\ControlFlowTok{else}\NormalTok{\{}\FunctionTok{return}\NormalTok{(}\DecValTok{0}\NormalTok{)\}}
\NormalTok{  \}}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{binom\_pascal}\NormalTok{(n}\SpecialCharTok{+}\DecValTok{1}\NormalTok{)                }\CommentTok{\# (2)}
  \FunctionTok{return}\NormalTok{(mat[n}\SpecialCharTok{+}\DecValTok{1}\NormalTok{,k}\SpecialCharTok{+}\DecValTok{1}\NormalTok{])                    }\CommentTok{\# (3)}
\NormalTok{\}}

\FunctionTok{binom\_coeff}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 45
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{choose}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 45
\end{verbatim}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  n = 0 muss abgefangen werden.
\item
  Wenn n nicht 0 ist, wird die Matrix erzeugt, die ausreichend groß ist, also n+1 Zeilen hat.
\item
  Der gesuchte Koeffizient steht dann in der Zeile n+1 und der Spalte k+1, da ja die Nummerierung der Zeilen und Spalten einer Matrix mit 1 beginnt und nicht mit 0.
\end{enumerate}

Aus Spaß können wir auch mal die beiden Implementationen vergleichen.
Dazu bauen wir eine fast identische Funktion, die mit den Listen arbeitet und geben beide in \texttt{bench::mark}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binom\_coeff\_l }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n,k)\{}
  \ControlFlowTok{if}\NormalTok{(n}\SpecialCharTok{==}\DecValTok{0}\NormalTok{)\{ }
    \ControlFlowTok{if}\NormalTok{(k}\SpecialCharTok{==}\DecValTok{0}\NormalTok{)\{}\FunctionTok{return}\NormalTok{(}\DecValTok{1}\NormalTok{)\} }\ControlFlowTok{else}\NormalTok{\{}\FunctionTok{return}\NormalTok{(}\DecValTok{0}\NormalTok{)\}}
\NormalTok{  \}}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{binom\_pascal}\NormalTok{(n}\SpecialCharTok{+}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{)}
  \FunctionTok{return}\NormalTok{(mat[[n}\SpecialCharTok{+}\DecValTok{1}\NormalTok{]][k}\SpecialCharTok{+}\DecValTok{1}\NormalTok{])}
\NormalTok{\}}

\FunctionTok{library}\NormalTok{(bench)}

\NormalTok{n }\OtherTok{\textless{}{-}} \DecValTok{30}
\NormalTok{k }\OtherTok{\textless{}{-}} \DecValTok{5}

\NormalTok{bench}\SpecialCharTok{::}\FunctionTok{mark}\NormalTok{(}\AttributeTok{iterations =} \DecValTok{100}\NormalTok{,}
            \AttributeTok{list =} \FunctionTok{binom\_coeff\_l}\NormalTok{(n,k),}
            \AttributeTok{mat =} \FunctionTok{binom\_coeff}\NormalTok{(n,k)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{autoplot}\NormalTok{(}\AttributeTok{type =} \StringTok{\textquotesingle{}violin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-98-1.pdf}

Die Matritzen-Variante ist wesentlich schneller, probieren wir noch einmal wie sich das für verschieden große Matritzen verhält:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sim }\OtherTok{\textless{}{-}}\NormalTok{ bench}\SpecialCharTok{::}\FunctionTok{press}\NormalTok{(}
  \AttributeTok{n =} \DecValTok{100} \SpecialCharTok{*} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,}
\NormalTok{  bench}\SpecialCharTok{::}\FunctionTok{mark}\NormalTok{(}\AttributeTok{iterations =} \DecValTok{100}\NormalTok{,}
              \AttributeTok{list =} \FunctionTok{binom\_coeff\_l}\NormalTok{(n,k),}
              \AttributeTok{mat =} \FunctionTok{binom\_coeff}\NormalTok{(n,k)) }
\NormalTok{) }

\FunctionTok{pmap\_dfr}\NormalTok{(}\FunctionTok{list}\NormalTok{(sim}\SpecialCharTok{$}\NormalTok{time,}
              \FunctionTok{names}\NormalTok{(sim}\SpecialCharTok{$}\NormalTok{expression),}
\NormalTok{              sim}\SpecialCharTok{$}\NormalTok{n),}
         \SpecialCharTok{\textasciitilde{}}\FunctionTok{tibble}\NormalTok{(}\AttributeTok{times =} \FunctionTok{as.numeric}\NormalTok{(..}\DecValTok{1}\NormalTok{),}
                 \AttributeTok{iterator =}\NormalTok{ ..}\DecValTok{2}\NormalTok{,}
                 \AttributeTok{reps =} \DecValTok{100} \SpecialCharTok{*}\NormalTok{ ..}\DecValTok{3}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ reps,}
             \AttributeTok{y =}\NormalTok{ times,}
             \AttributeTok{color =}\NormalTok{ iterator)) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =}\NormalTok{ .}\DecValTok{1}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{stat\_summary}\NormalTok{(}\AttributeTok{geom=}\StringTok{\textquotesingle{}line\textquotesingle{}}\NormalTok{,}
               \AttributeTok{fun =}\NormalTok{ median) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}\AttributeTok{y =} \StringTok{\textquotesingle{}Zeit [s]\textquotesingle{}}\NormalTok{,}
       \AttributeTok{x =} \StringTok{\textquotesingle{}Iterierte Werte\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{scale\_color\_brewer}\NormalTok{(}\AttributeTok{palette =} \StringTok{\textquotesingle{}Dark2\textquotesingle{}}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_smooth}\NormalTok{(}\AttributeTok{method =} \StringTok{\textquotesingle{}lm\textquotesingle{}}\NormalTok{,}
              \AttributeTok{formula =}\NormalTok{ y }\SpecialCharTok{\textasciitilde{}} \FunctionTok{poly}\NormalTok{(x, }\DecValTok{2}\NormalTok{)) }\SpecialCharTok{+}
  \FunctionTok{theme\_minimal}\NormalTok{()}

\FunctionTok{ggsave}\NormalTok{(}\StringTok{\textquotesingle{}imgs/list\_mat\_pascal.png\textquotesingle{}}\NormalTok{,}
       \AttributeTok{scale =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=68.06in]{imgs/list_mat_pascal}

\hypertarget{matrizen-und-chi2}{%
\section{\texorpdfstring{Matrizen und \(\chi^2\)}{Matrizen und \textbackslash chi\^{}2}}\label{matrizen-und-chi2}}

Beispiele für Matrizen sind Kontingenztafeln. Hier spielen die Randsummen eine wichtige Rolle, die \texttt{apply}-Funktion bietet die oben schon erwähnte Möglichkeit, solche Randsummen besonders einfach zu bilden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(m, }\AttributeTok{MARGIN =} \DecValTok{1}\NormalTok{, }\AttributeTok{FUN =}\NormalTok{ sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 6
\end{verbatim}

Die Argumente FUN und MARGIN müssen hier angegeben werden. Im Beispiel sollen Summen gebildet werden (FUN = sum), wobei ein Index festgehalten wird, hier Zeilenindex (MARGIN = 1). Der andere Index (hier dann der Spaltenindex) ist der Index, über den summiert wird. Sind die Einträge der Matix \(x_{ij}\), so werden also die Summen \(\sum_j x_{ij}\) gebildet, die Randsummen am rechten Rand.

Dasselbe mit MARGIN = 2 liefert die Summen der Einträge in den jeweiligen Spalten, also die Randsummen am unteren Rand, ausprobieren!

An der Stelle von sum können auch andere Funktionen eingesetzt werden, beispielsweise prod, wenn nicht Summen, sondern Produkte gebildet werden sollen (ausprobieren!).

Alternativ sind in R mit \texttt{colSums} und \texttt{rowSums} Funktionen zur Bildung von Spalten- und Zeilensummen schon implementiert, außerdem könnten wir auch eine \texttt{for}-Schleife nutzen, um die Summen zu berechnen.

Überlege zuerst, wie man Eine Funktion schreiben könnte, die mit denselben Argumenten wie \texttt{apply} mit Hilfe einer \texttt{for}-Schleife Zeilen- oder Spaltenweise Werte aggregiert.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_apply }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(m,MARGIN,FUN, ...)\{}
  \ControlFlowTok{if}\NormalTok{(MARGIN }\SpecialCharTok{==} \DecValTok{2}\NormalTok{)\{}
\NormalTok{    m }\OtherTok{\textless{}{-}} \FunctionTok{t}\NormalTok{(m)}
\NormalTok{  \}}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(m))}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(m))) \{}
\NormalTok{    out[i] }\OtherTok{\textless{}{-}} \FunctionTok{FUN}\NormalTok{(m[i,], ...)}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(out)}
\NormalTok{\}}
\FunctionTok{my\_apply}\NormalTok{(m, }\DecValTok{2}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(m, }\DecValTok{2}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 7
\end{verbatim}

Nutze jetzt deine \texttt{for}-\texttt{apply}-Alternative, \texttt{apply} und \texttt{rowSums} um mit bench::mark zu testen, welche dieser Funktionen am besten in 100 Tests auf Basis einer 100x100-Matrix performed.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(bench)}
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10000}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{100}\NormalTok{)}
\NormalTok{bmark }\OtherTok{\textless{}{-}} \FunctionTok{mark}\NormalTok{(}
  \AttributeTok{iterations =} \DecValTok{100}\NormalTok{,}
  \AttributeTok{for\_apply =} \FunctionTok{my\_apply}\NormalTok{(m, }\DecValTok{1}\NormalTok{, sum),}
  \AttributeTok{apply =} \FunctionTok{apply}\NormalTok{(m, }\DecValTok{1}\NormalTok{, sum),}
  \AttributeTok{rowSums =} \FunctionTok{rowSums}\NormalTok{(m)}
\NormalTok{)}
\NormalTok{bmark }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{autoplot}\NormalTok{(}\AttributeTok{type =} \StringTok{\textquotesingle{}violin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-103-1.pdf}

Eine dieser Funktionen können wir nun benutzen, um den chi-Quadrat-Wert einer Kontingenztafel zu bestimmen.

Schreibe dazu eine Funktion, die für eine Matrix \texttt{x} einen chi-Quadrat-Wert nach der Formel \[\chi^2=\sum_{i,j}\frac{(f_{o,ij}-f_{e,ij})^2}{f_{e,ij}} = \sum_{i,j}\frac{\left(n_{ij}- \frac{n_{i\cdot} n_{\cdot j}}{n}\right)^2}{\frac{n_{i\cdot} n_{\cdot j}}{n}}\] berechnet.
Für diese Funktion gibt es zwei Möglichkeiten zur Implementation. Zum Einen können geschachtelte \texttt{for}-Schleifen verwendet werden, zur anderen kann die \texttt{sweep}-Funktion benutzt werden.
\texttt{sweep()} kann benutzt werden um eine Matrix zeilen-oder spaltenweise mit einem Vektor zu transformieren. Dabei kann ein arithmetsicher Operator (+,-,\ldots) genutzt werden um die Werte zu verrechnen. Hier ist ein einfaches Beispiel in dem mit \texttt{sweep} das kleine 1-mal-1 in einer 10x10-Matrix erstellt wird:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\AttributeTok{each =} \DecValTok{10}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{10}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1    2    3    4    5    6    7    8    9    10
##  [2,]    1    2    3    4    5    6    7    8    9    10
##  [3,]    1    2    3    4    5    6    7    8    9    10
##  [4,]    1    2    3    4    5    6    7    8    9    10
##  [5,]    1    2    3    4    5    6    7    8    9    10
##  [6,]    1    2    3    4    5    6    7    8    9    10
##  [7,]    1    2    3    4    5    6    7    8    9    10
##  [8,]    1    2    3    4    5    6    7    8    9    10
##  [9,]    1    2    3    4    5    6    7    8    9    10
## [10,]    1    2    3    4    5    6    7    8    9    10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sweep}\NormalTok{(m, }\CommentTok{\# Matrix}
      \AttributeTok{MARGIN =} \DecValTok{1}\NormalTok{, }\CommentTok{\# zeilenweise, also pro Zeile ein anderer Wert des Vektors}
      \AttributeTok{STATS =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\CommentTok{\# der Vektor mit dem multipliziert werden soll}
      \AttributeTok{FUN =} \StringTok{\textquotesingle{}*\textquotesingle{}}\NormalTok{) }\CommentTok{\# Angabe dass multipliziert werden soll}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1    2    3    4    5    6    7    8    9    10
##  [2,]    2    4    6    8   10   12   14   16   18    20
##  [3,]    3    6    9   12   15   18   21   24   27    30
##  [4,]    4    8   12   16   20   24   28   32   36    40
##  [5,]    5   10   15   20   25   30   35   40   45    50
##  [6,]    6   12   18   24   30   36   42   48   54    60
##  [7,]    7   14   21   28   35   42   49   56   63    70
##  [8,]    8   16   24   32   40   48   56   64   72    80
##  [9,]    9   18   27   36   45   54   63   72   81    90
## [10,]   10   20   30   40   50   60   70   80   90   100
\end{verbatim}

Suche Dir einen der beiden Wege aus und setze diesen um.
Mit der \texttt{chisq.test}-Funktion könnt Ihr überprüfen, ob die bestehende Implementation auf dieselbe Lösung kommt.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{for\_chisq }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(m)\{                   }\CommentTok{\# (1)}
\NormalTok{  I }\OtherTok{\textless{}{-}} \FunctionTok{dim}\NormalTok{(m)[}\DecValTok{1}\NormalTok{]                            }\CommentTok{\# (2)}
\NormalTok{  J }\OtherTok{\textless{}{-}} \FunctionTok{dim}\NormalTok{(m)[}\DecValTok{2}\NormalTok{]}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(m)                               }\CommentTok{\# (3)}
\NormalTok{  e }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,I}\SpecialCharTok{*}\NormalTok{J),}\AttributeTok{nrow =}\NormalTok{ I)          }\CommentTok{\# (4)}
\NormalTok{  nip }\OtherTok{\textless{}{-}} \FunctionTok{rowSums}\NormalTok{(m)                         }\CommentTok{\# (5)}
\NormalTok{  npj }\OtherTok{\textless{}{-}} \FunctionTok{colSums}\NormalTok{(m)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(I))\{                         }\CommentTok{\# (6)}
    \ControlFlowTok{for}\NormalTok{(j }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(J))\{}
\NormalTok{      e[i,j] }\OtherTok{\textless{}{-}}\NormalTok{ nip[i] }\SpecialCharTok{*}\NormalTok{ npj[j]}\SpecialCharTok{/}\NormalTok{n}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  e1 }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,I}\SpecialCharTok{*}\NormalTok{J),}\AttributeTok{nrow =}\NormalTok{ I)         }\CommentTok{\# (7)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(I))\{}
    \ControlFlowTok{for}\NormalTok{(j }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(J))\{}
\NormalTok{      e1[i,j] }\OtherTok{\textless{}{-}}\NormalTok{ (m[i,j]}\SpecialCharTok{{-}}\NormalTok{e[i,j])}\SpecialCharTok{\^{}}\DecValTok{2}\SpecialCharTok{/}\NormalTok{e[i,j]   }\CommentTok{\# (8)}
\NormalTok{    \}}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{sum}\NormalTok{(e1))                           }\CommentTok{\# (9)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Die Matrix x ist die zu untersuchende Kontingenztafel mit absoluten Häufigkeiten. Zur Berechnung wird die Formel Folie 165 QM1 benutzt.
\item
  Die Zeilenzahl I der Matrix wird bestimmt (zur Erinnerung: R unterscheidet zwischen Groß- und Kleinbuchstaben), nächste Zeile: Spaltenzahl J.
\item
  Die Gesamtzahl n aller Beobachtungen.
\item
  In der Matrix e sollen nachher die erwarteten Häufigkeiten stehen, hier wird die Matrix angelegt und mit Nullen gefüllt.
\item
  Vektor der rechten Randsummen (\(n_{i.}\)), nächste Zeile untere Randsummen (\(n_{.j}\)).
\item
  Die Matrix e wird mit den erwarteten Häufigkeiten gefüllt.
\item
  In der Matrix e1 sollen nachher die Summanden für den chi-Quadrat-Koeffizienten stehen, hier wird sie mit Nullen gefüllt angelegt.
\item
  Die Matrix e1 wird mit den Summanden gefüllt.
\item
  Der chi-Quadrat-Koeffizient ist jetzt die Summe der Zahlen in der Matrix e1.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[numbers=left,,]
\NormalTok{mat\_chisq }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(m) \{}
\NormalTok{  e }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\FunctionTok{colSums}\NormalTok{(m),   }
                  \AttributeTok{each =} \FunctionTok{nrow}\NormalTok{(m)),}
              \AttributeTok{nrow =} \FunctionTok{nrow}\NormalTok{(m))}
  
\NormalTok{  e }\OtherTok{\textless{}{-}} \FunctionTok{sweep}\NormalTok{(e, }
             \FunctionTok{rowSums}\NormalTok{(m), }
             \AttributeTok{MARGIN =} \DecValTok{1}\NormalTok{, }
             \AttributeTok{FUN =} \StringTok{\textquotesingle{}*\textquotesingle{}}\NormalTok{) }
\NormalTok{  e }\OtherTok{\textless{}{-}}\NormalTok{ e }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(m)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{sum}\NormalTok{((m }\SpecialCharTok{{-}}\NormalTok{ e) }\SpecialCharTok{\^{}} \DecValTok{2} \SpecialCharTok{/}\NormalTok{ e))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{table}
\centering
\begin{tabular}[t]{rl}
\toprule
Zeile & Was passiert?\\
\midrule
1 & \\
2 & Matrix wird aufgefüllt mit Spaltensummen (wir erinnern uns dass Matrizen in R spaltenweise aufgefüllt werden)\\
3 & und zwar wird jede Spaltensumme pro Spalte in jede Zeile geschrieben\\
4 & und die Matrix soll dieselben Maße wie m haben.\\
5 & \\
\addlinespace
6 & Wir nehmen die Matrix der Spaltensummen\\
7 & und die Zeilensummen\\
8 & gehen zeilenweise vor (jede Zeile eine Zeilensumme)\\
9 & und multiplizieren die ni. und n.j in jeder Zelle.\\
10 & Dann müssen wir die Zellen nur noch durch die Gesamtzahl der Beobachtungen teilen und haben die eij.\\
\addlinespace
11 & Als letztes quadrieren wir die Abweichungen der Matirx von den eij, teilen die Ergebnisse durch die eij und summieren alles auf.\\
12 & \\
\bottomrule
\end{tabular}
\end{table}

Kleine Zusatzaufgabe falls Interesse besteht:
Benchmarke die zwei Implementationen (gerne die aus der Musterlösung, Du musst nicht noch selber die andere umsetzen\footnote{wenn Du nicht willst}) und die folgende Variante gegeneinander:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unname}\NormalTok{(}\FunctionTok{chisq.test}\NormalTok{(m)}\SpecialCharTok{$}\NormalTok{statistic)}
\end{Highlighting}
\end{Shaded}

Was kommt raus?
Hast Du eine Idee, warum das Ergebnis so aussieht wie es aussieht?

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10000}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{100}\NormalTok{)}
\NormalTok{bmark }\OtherTok{\textless{}{-}}\NormalTok{ bench}\SpecialCharTok{::}\FunctionTok{mark}\NormalTok{(}
  \AttributeTok{iterations =} \DecValTok{1000}\NormalTok{,}
  \AttributeTok{forX2 =} \FunctionTok{for\_chisq}\NormalTok{(m),}
  \AttributeTok{matX2 =} \FunctionTok{mat\_chisq}\NormalTok{(m),}
  \AttributeTok{RX2 =} \FunctionTok{unname}\NormalTok{(}\FunctionTok{chisq.test}\NormalTok{(m)}\SpecialCharTok{$}\NormalTok{statistic)}
\NormalTok{)}
\NormalTok{bmark }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{autoplot}\NormalTok{(}\AttributeTok{type =} \StringTok{\textquotesingle{}violin\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Robustheit_files/figure-latex/unnamed-chunk-108-1.pdf}

Als letztes baue einen chi-Quadrat-Test auf Unabhängigkeit mit der \(\chi^2\)-Statistik aus unseren Funktionen durchführt und die Originalmatrix mit Randsummen, die Gesamtzahl an Beobachtungen, die Teststatistik, die Freiheitsgrade und das p\footnote{In unserem Fall müssen wir die Teststatistik mit der \(\chi^2_{(I-1)(J-1)}\)-Verteilung vergleichen, die R-Funktion für das Finden eines gegebenen \(\chi^2\)-Perzentils ist \texttt{pchisq()}} zurückgibt.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_chisq.test }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(m)\{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{statistic =} \FunctionTok{mat\_chisq}\NormalTok{(m))}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(m, }\FunctionTok{colSums}\NormalTok{(m))}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(mat, }\FunctionTok{rowSums}\NormalTok{(mat))}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{mat }\OtherTok{\textless{}{-}}\NormalTok{ mat}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{n }\OtherTok{\textless{}{-}}\NormalTok{ mat[}\FunctionTok{nrow}\NormalTok{(mat), }\FunctionTok{ncol}\NormalTok{(mat)]}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{df }\OtherTok{\textless{}{-}}\NormalTok{ (}\FunctionTok{nrow}\NormalTok{(m)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{) }\SpecialCharTok{*}\NormalTok{ (}\FunctionTok{ncol}\NormalTok{(m) }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{)}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{pchisq}\NormalTok{(out}\SpecialCharTok{$}\NormalTok{statistic,}
                  \AttributeTok{df =}\NormalTok{ out}\SpecialCharTok{$}\NormalTok{df,}
                  \AttributeTok{lower.tail =}\NormalTok{ F)}
  \FunctionTok{return}\NormalTok{(out)}
\NormalTok{\}}
\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{,}\AttributeTok{ncol =} \DecValTok{3}\NormalTok{)}
\FunctionTok{my\_chisq.test}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $statistic
## [1] 0.46875
## 
## $mat
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   12
## [2,]    2    5    8   15
## [3,]    3    6    9   18
## [4,]    6   15   24   45
## 
## $n
## [1] 45
## 
## $df
## [1] 4
## 
## $p
## [1] 0.976471
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{chisq.test}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in chisq.test(m): Chi-squared approximation may be incorrect
\end{verbatim}

\begin{verbatim}
## 
##  Pearson's Chi-squared test
## 
## data:  m
## X-squared = 0.46875, df = 4, p-value = 0.9765
\end{verbatim}

Als kleinen Zusatz könnt Ihr Euch noch überlegen, wie Ihr eine eigene print-Funktion für Euren Test schreiben könntet.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_chisq.test }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(m)\{}
\NormalTok{  out }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{statistic =} \FunctionTok{mat\_chisq}\NormalTok{(m))}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(m, }\FunctionTok{colSums}\NormalTok{(m))}
\NormalTok{  mat }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(mat, }\FunctionTok{rowSums}\NormalTok{(mat))}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{mat }\OtherTok{\textless{}{-}}\NormalTok{ mat}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{n }\OtherTok{\textless{}{-}}\NormalTok{ mat[}\FunctionTok{nrow}\NormalTok{(mat), }\FunctionTok{ncol}\NormalTok{(mat)]}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{df }\OtherTok{\textless{}{-}}\NormalTok{ (}\FunctionTok{nrow}\NormalTok{(m)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{) }\SpecialCharTok{*}\NormalTok{ (}\FunctionTok{ncol}\NormalTok{(m) }\SpecialCharTok{{-}} \DecValTok{1}\NormalTok{)}
\NormalTok{  out}\SpecialCharTok{$}\NormalTok{p }\OtherTok{\textless{}{-}} \FunctionTok{pchisq}\NormalTok{(out}\SpecialCharTok{$}\NormalTok{statistic,}
                  \AttributeTok{df =}\NormalTok{ out}\SpecialCharTok{$}\NormalTok{df,}
                  \AttributeTok{lower.tail =}\NormalTok{ F)}
  \FunctionTok{attributes}\NormalTok{(out)}\SpecialCharTok{$}\NormalTok{class }\OtherTok{\textless{}{-}} \StringTok{\textquotesingle{}my\_chisqtest\textquotesingle{}}
  \FunctionTok{return}\NormalTok{(out)}
\NormalTok{\}}

\NormalTok{print.my\_chisqtest }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, ...)\{}
  \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}Chi{-}Quadrat{-}Test auf Unabhängigkeit\textquotesingle{}}\NormalTok{)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}Chi\^{}2\_(\textquotesingle{}}\NormalTok{,x}\SpecialCharTok{$}\NormalTok{df,}\StringTok{\textquotesingle{}) = \textquotesingle{}}\NormalTok{,x}\SpecialCharTok{$}\NormalTok{statistic,}\StringTok{\textquotesingle{}; p = \textquotesingle{}}\NormalTok{,x}\SpecialCharTok{$}\NormalTok{p, }\AttributeTok{sep =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{\textquotesingle{}Der Test ist damit auf 5\%{-}Niveau\textquotesingle{}}\NormalTok{,}
      \FunctionTok{ifelse}\NormalTok{(x}\SpecialCharTok{$}\NormalTok{p}\SpecialCharTok{\textless{}}\NormalTok{.}\DecValTok{05}\NormalTok{,}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{} nicht \textquotesingle{}}\NormalTok{),}
      \StringTok{\textquotesingle{}signifikant!\textquotesingle{}}\NormalTok{, }\AttributeTok{sep =} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\NormalTok{\}}

\NormalTok{m }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{,}\AttributeTok{ncol =} \DecValTok{3}\NormalTok{)}
\FunctionTok{my\_chisq.test}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Chi-Quadrat-Test auf Unabhängigkeit
## Chi^2_(4) = 0.46875; p = 0.976471
## 
## Der Test ist damit auf 5%-Niveau nicht signifikant!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{chisq.test}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in chisq.test(m): Chi-squared approximation may be incorrect
\end{verbatim}

\begin{verbatim}
## 
##  Pearson's Chi-squared test
## 
## data:  m
## X-squared = 0.46875, df = 4, p-value = 0.9765
\end{verbatim}

\hypertarget{t-test}{%
\section{t-Test}\label{t-test}}

Erstelle eine Funktion \texttt{my\_dkw}, die für einen gegebenen Vektor \texttt{x} deskriptive Kennwerte als Liste zurückgibt.
Diese Liste soll die Stichprobengröße\footnote{Länge des Vektors}, den Mittelwert und die Varianz beinhalten.
Mit einem optionalen Argument \texttt{corrected} soll angegeben werden können, ob die korrigierte oder die unkorrigierte Stichprobenvarianz ausgegeben werden soll.

Antwort

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_dkw }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,}\AttributeTok{corrected=}\ConstantTok{FALSE}\NormalTok{)\{ }
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)                  }
\NormalTok{  m }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x)}\SpecialCharTok{/}\NormalTok{n                     }
\NormalTok{  sqa }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{((x}\SpecialCharTok{{-}}\NormalTok{m)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)                 }
\NormalTok{  var }\OtherTok{\textless{}{-}}\NormalTok{ sqa}\SpecialCharTok{/}\FunctionTok{ifelse}\NormalTok{(corrected, n}\DecValTok{{-}1}\NormalTok{, n)  }
  \FunctionTok{return}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{n =}\NormalTok{ n,}\AttributeTok{m =}\NormalTok{ m, }\AttributeTok{v =}\NormalTok{ var))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Mit Hilfe der vorangehenden Funktion soll nun ein rechtsseitiger Zwei-Stichproben-t-Test für unabhängige Stichproben bei vorausgesetzter Varianzhomogenität geschrieben werden.

Als Argumente werden die Vektoren der beiden Stichproben eingegeben, die zu testende Vermutung soll sein, dass der zur ersten Stichprobe gehörende Erwartungswert größer ist als der zur zweiten Stichprobe gehörende.

Antwort

Hier eine mögliche Realisierung:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_t\_test0 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x1,x2)\{      }\CommentTok{\# (1)}
\NormalTok{  dkw1 }\OtherTok{\textless{}{-}} \FunctionTok{my\_dkw}\NormalTok{(x1)                }\CommentTok{\# (2)}
\NormalTok{  dkw2 }\OtherTok{\textless{}{-}} \FunctionTok{my\_dkw}\NormalTok{(x2)}
\NormalTok{  n1 }\OtherTok{\textless{}{-}}\NormalTok{ dkw1}\SpecialCharTok{$}\NormalTok{n                      }\CommentTok{\# (3)}
\NormalTok{  n2 }\OtherTok{\textless{}{-}}\NormalTok{ dkw2}\SpecialCharTok{$}\NormalTok{n}
\NormalTok{  S1q }\OtherTok{\textless{}{-}}\NormalTok{ dkw1}\SpecialCharTok{$}\NormalTok{v                     }\CommentTok{\# (4)}
\NormalTok{  S2q }\OtherTok{\textless{}{-}}\NormalTok{ dkw2}\SpecialCharTok{$}\NormalTok{v}
\NormalTok{  sq }\OtherTok{\textless{}{-}}\NormalTok{ (n1 }\SpecialCharTok{*}\NormalTok{ S1q }\SpecialCharTok{+}\NormalTok{ n2 }\SpecialCharTok{*}\NormalTok{ S2q)}\SpecialCharTok{/}\NormalTok{(n1}\SpecialCharTok{+}\NormalTok{n2}\DecValTok{{-}2}\NormalTok{)    }\CommentTok{\# (5)}
\NormalTok{  vf }\OtherTok{\textless{}{-}}\NormalTok{ (n1}\SpecialCharTok{+}\NormalTok{n2)}\SpecialCharTok{/}\NormalTok{(n1}\SpecialCharTok{*}\NormalTok{n2)             }\CommentTok{\# (6)}
\NormalTok{  nenner }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(vf}\SpecialCharTok{*}\NormalTok{sq)             }\CommentTok{\# (7)}
\NormalTok{  t }\OtherTok{\textless{}{-}}\NormalTok{ (dkw1}\SpecialCharTok{$}\NormalTok{m}\SpecialCharTok{{-}}\NormalTok{dkw2}\SpecialCharTok{$}\NormalTok{m)}\SpecialCharTok{/}\NormalTok{nenner       }\CommentTok{\# (8)}
\NormalTok{  df }\OtherTok{\textless{}{-}}\NormalTok{ n1}\SpecialCharTok{+}\NormalTok{n2}\DecValTok{{-}2}                     \CommentTok{\# (9)}
  \FunctionTok{return}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\FunctionTok{pt}\NormalTok{(t,df))                }\CommentTok{\# (10)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Als Argumente werden die beiden Stichprobenvektoren eingegeben. Der Test ist in dieser Form nicht richtig befriedigend, daher die 0 am Namen. Ihre Aufgabe ist es später, die Funktion so zu modifizieren (dann mit einem anderen Namen), dass sie Ihren Wünschen entspricht. In der Funktion werden die einzelnen Bestandteile des t-Bruchs ermittelt umd am Ende zusammengebaut.
\item
  Die Kennwerte der ersten Stichprobe werden ermittelt, in der nächsten Zeile die der zweiten.
\item
  Die Länge der ersten Stichprobe wird extrahiert, da diese Länge häufiger vorkommt, ist ein kürzerer Name praktisch. Natürlich hätte man diese Zeile auch weglassen können; dann hätte man n1 im Folgenden überall durch dkw1\$n ersetzten müssen. Entsprechend in der nächsten Zeile für die zweite Stichprobe.
\item
  Die Varianz der ersten Stichprobe wird extrahiert; sie bekommt den kürzeren Namen S1q (q für Quadrat), ausnahmsweise ist der erste Buchstabe groß, um daran zu erinnern, dass es die ``normale'' Varianz \(S_1^2\) und nicht die korrigierte Stichprobenvarianz \(s_1^2\) ist. Entsprechend die nächste Zeile für die zweite Stichprobe.
\item
  Hier wird \(s^2\) ausgerechnet. Die Rechnung entspricht nicht der Standardformel, das Ergebnis ist aber dasselbe wegen \(nS^2=(n-1)s^2\). Der Vorteil des Rechnens mit \(S^2\) ist der, dass hier auch eine Stichprobe einen Umfang von 1 haben kann, erst wenn beide Stichproben Umfang 1 haben, entsteht ein Problem. Ein Teil der Verbesserung könnte sein, dieses Problem abzufangen und durch eine print-Ausgabe darauf hinzuweisen.
\item
  Der Vorfaktor im Nenner.
\item
  Der Nenner.
\item
  Der t-Bruch.
\item
  Die Freiheitsgrade
\item
  Ergebnis ist der p-Wert des rechtsseitigen Tests.
\end{enumerate}

Aufgaben:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Stellen Sie sich vor, die Funktion würde nicht das richtige Ergebnis liefern. Fügen Sie Anweisungen ein, mit denen Sie die Zwischenresultate kontrollieren können um so einen möglichen Fehler zu finden!
\item
  Kontrollieren Sie das Ergebnis des t-Tests auf Folie 73 der Einführung! Die Daten dazu sind nicht explizit gegeben, lassen sich aber aus den Histogrammen auf Folie 46 (bis auf die unwesentliche Reihenfolge) leicht rekonstruieren (beachte: es handelt sich jeweils um 20 Werte). Bei der Herstellung der Datenvektoren kann die Funktion \texttt{rep} nützlich sein, mit \texttt{my\_dkw} können Sie die Kennwerte der Stichproben überprüfen. Achtung: die Konvention bei der Differenz der Mittelwerte ist auf den Folien anders als hier!
\item
  Das Ergebnis ist unbefriedigend, da Sie ja nur am p-Wert erkennen können, ob der Test signifikant ist. Ändern Sie daher die Funktion geeignet ab, so dass weitere Kennwerte des Tests ausgegeben werden, benutzen Sie beispielsweise die Möglichkeiten einer Liste und/oder einer spezifischen \texttt{print}-Funktion.
\item
  Unbefriedigend ist auch, dass nur ein rechtsseitiger Test gerechnet werden kann. Ändern Sie die Funktion daher weiter so ab, dass auch linksseitige oder zweiseitige Tests möglich sind (Sie müssen dann ein weiteres Argument hinzufügen, mit dem Sie der Funktion Ihre Wünsche bekanntgeben, in der Funktion können Sie dann beispielsweise mit if - else arbeiten).
\item
  Schreiben Sie eine ähnliche Funktion für den Einstichproben-t-Test; hier ist als weiteres Argument der Erwartungswert unter H0 einzugeben, der vielleicht standardmäßig 0 ist.
\item
  Schreiben Sie eine ähnliche Funktion für den Zweistichproben-t-Test mit abhängigen Stichproben. Hier könnte es sich empfehlen, die Daten in Form einer Matrix einzugeben. Sinnvollerweise benutzen Sie nach Differenzbildung dann die Funktion für den Einstichproben-t-Test aus (5).
\end{enumerate}

Kontrollieren Sie Ihre Funktionen immer an kleinen Datensätzen, in denen Sie auch von Hand rechnen können, beispielsweise können Sie Aufgaben aus QM2 benutzen.

\hypertarget{t-vertrauensintervall}{%
\subsection{t-Vertrauensintervall}\label{t-vertrauensintervall}}

Hier gleich die Funktion:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_t\_vi }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,}\AttributeTok{p=}\NormalTok{.}\DecValTok{95}\NormalTok{)\{       }\CommentTok{\# (1)}
\NormalTok{  dkw }\OtherTok{\textless{}{-}} \FunctionTok{my\_dkw}\NormalTok{(x, }\AttributeTok{corrected =}\NormalTok{ T)   }\CommentTok{\# (2)}
\NormalTok{  n }\OtherTok{\textless{}{-}}\NormalTok{ dkw}\SpecialCharTok{$}\NormalTok{n                        }\CommentTok{\# (3)}
\NormalTok{  tfrak }\OtherTok{\textless{}{-}} \FunctionTok{qt}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{(}\DecValTok{1}\SpecialCharTok{{-}}\NormalTok{p)}\SpecialCharTok{/}\DecValTok{2}\NormalTok{, n}\DecValTok{{-}1}\NormalTok{)       }\CommentTok{\# (4)}
\NormalTok{  sem }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(dkw}\SpecialCharTok{$}\NormalTok{v}\SpecialCharTok{/}\NormalTok{n)              }\CommentTok{\# (5)}
\NormalTok{  hb }\OtherTok{\textless{}{-}}\NormalTok{ tfrak }\SpecialCharTok{*}\NormalTok{ sem                 }\CommentTok{\# (6)}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{c}\NormalTok{(dkw}\SpecialCharTok{$}\NormalTok{m}\SpecialCharTok{{-}}\NormalTok{hb,dkw}\SpecialCharTok{$}\NormalTok{m}\SpecialCharTok{+}\NormalTok{hb))      }\CommentTok{\# (7)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Argumente sind der Datenvektor x und das gewünschte Niveau p, hier mit .95 vorbelegt.
\item
  Die Kennwerte der Daten, gleich wird mit der korrigierten Stichprobenvarianz gerechnet.
\item
  Stichprobenumfang, kommt öfter vor, daher ist ein kürzerer Name praktisch.
\item
  Das alpha/2-Fraktil (alpha ist 1-p).
\item
  Der SEM.
\item
  Die halbe Breite.
\item
  Ergebnis: Vektor aus unterer und oberer Grenze des Vertrauensintervalls.
\end{enumerate}

Aufgabe: Prüfen Sie an bekannten Daten (beispielsweise Einleitung Folie 61) nach, ob die Funktion das richtige Intervall liefert!

\hypertarget{zufallsstichproben-mit-diskreten-werten}{%
\subsection{Zufallsstichproben mit diskreten Werten}\label{zufallsstichproben-mit-diskreten-werten}}

Die passende Funktion ist hier sample. Beispiel:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{), }\DecValTok{20}\NormalTok{, }\AttributeTok{replace =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 5 4 6 6 2 5 6 4 1 3 6 1 1 4 4 4 1 4 2 5
\end{verbatim}

Hier wird eine Zufallsstichprobe aus den Zahlen von 1 bis 6 gezogen (seq(6)), deren Umfang 20 ist, wobei Zahlen auch mehrfach gezogen werden können (replace = T, Achtung: Standardwert ist F, siehe Hilfe). Hier wird also eine zufällige Serie von 20 Würfelergebnissen erzeugt.

Etwas komplizierter: Das Wahrnehmungsexperiment aus dem 1. Semester, die Wahrscheinlichkeiten der möglichen Fehlerzahlen von 0 bis 5 seien durch die W-Funktion Folie 77 gegeben. Es sollen 20 Werte erzeugt werden:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{, }\AttributeTok{replace =}\NormalTok{ T, }\AttributeTok{prob =} \FunctionTok{c}\NormalTok{(.}\DecValTok{1}\NormalTok{,.}\DecValTok{15}\NormalTok{,.}\DecValTok{35}\NormalTok{,.}\DecValTok{25}\NormalTok{,.}\DecValTok{1}\NormalTok{,.}\DecValTok{05}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 0 2 1 2 3 1 2 1 4 2 3 4 3 1 3 0 0 2 2 2
\end{verbatim}

Hier sind die möglichen Werte die Zahlen von 0 bis 5, die man beispielsweise durch seq(6)-1 erhält. Möglich wäre auch

\texttt{seq(from\ =\ 0,\ to\ =\ 5)}

kürzer

\texttt{seq(0,\ 5)}

oder noch einfacher

\texttt{0:5}

Zusätzlich werden durch den Parameter prob die Wahrscheinlichkeiten dieser Zahlen angegeben.

Wenn diese Verteilung öfter gebraucht wird, ist es sinnvoll, den Vektor der Wahrscheinlichkeiten unter einem geeigneten Namen abzuspeichern, um dann nur noch diesen Namen in die Anweisung einsetzen zu müssen, entsprechend für den Vektor möglicher Werte.

Zu prüfen ist nun, ob die ``Zufallsstichproben'' auch den Forderungen entsprechen; dazu sollen bei einer großen derartigen Stichprobe die relativen Häufigkeiten der möglichen Werte ermittelt werden, die dann hoffentlich etwa gleich den vorgegebenen Wahrscheinlichkeiten sind.

Obwohl R bessere Möglichkeiten zur Verfügung stellt, soll zur Übung das Auszählen mit primitive Mitteln bewerkstelligt werden. Zunächst: Wie oft kommt ein Element a in einem Vektor x vor?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{anzahl }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(a, x)\{        }\CommentTok{\# (1)}
\NormalTok{  l }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{  z }\OtherTok{\textless{}{-}} \DecValTok{0}                         \CommentTok{\# (2)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq\_len}\NormalTok{(l))\{}
    \ControlFlowTok{if}\NormalTok{(x[i] }\SpecialCharTok{==}\NormalTok{ a) z }\OtherTok{\textless{}{-}}\NormalTok{ z }\SpecialCharTok{+} \DecValTok{1}     \CommentTok{\# (3)}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(z)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Die Argumente der Funktion sind das untersuchte Element a und der Vektor x.
\item
  Eine Zählvariable z wird eingerichtet, der Wert dieses ``Zählers'' z wird auf 0 gesetzt
\item
  Nacheinander werden die Komponenten von x untersucht, bei Übereinstimmung mit a wird der Zähler um 1 erhöht
\end{enumerate}

Tabelle der relativen Häufigkeiten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v2trh }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(w, x)\{         }\CommentTok{\# (1)}
\NormalTok{  n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(x)}
\NormalTok{  ah }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,}\FunctionTok{length}\NormalTok{(w))         }\CommentTok{\# (2)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(}\FunctionTok{length}\NormalTok{(w)))}
\NormalTok{    \{}
\NormalTok{    ah[i] }\OtherTok{\textless{}{-}} \FunctionTok{anzahl}\NormalTok{(w[i],x)      }\CommentTok{\# (3)}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{rbind}\NormalTok{(w,ah}\SpecialCharTok{/}\NormalTok{n))          }\CommentTok{\# (4)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Name: Vektor zu Tabelle relativer Häufigkeiten, Argumente: w: mögliche Werte, x: untersuchter Vektor. Wichtig ist, dass w alle Werte enthält, die in x vorkommen können, sonst ist die Summe der ``relativen Häufigkeiten'' am Ende nicht 1.
\item
  in ah werden die absoluten Häufigkeiten der Werte in w abgespeichert, Vorbelegung mit Nullen.
\item
  Für jeden möglichen Wert wird in ah die Häufigkeit des Auftretens eingetragen.
\item
  Das Ergebnis ist eine Matrix, die hier dadurch entsteht, dass man die beiden Vektoren w und ah/n als Zeilen (r: row) zusammenfügt.
\end{enumerate}

Beispiel:

Funktioniert die Erzeugung von zufälligen Würfelergebnissen einigermaßen? Es soll 10000 Mal gewürfelt werden, die Tabelle der relativen Häufigkeiten ist dann zu untersuchen! Achtung: Es sollte unbedingt verhindert werden, dass das Ergebnis des Würfelns ausgegeben wird! Dazu wird das Ergebnis gleich in einer Variable abgespeichert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{),}\DecValTok{10000}\NormalTok{,}\AttributeTok{replace =}\NormalTok{ T)}
\FunctionTok{v2trh}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{),x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    [,1]   [,2]   [,3]   [,4]   [,5]   [,6]
## w 1.000 2.0000 3.0000 4.0000 5.0000 6.0000
##   0.166 0.1713 0.1646 0.1651 0.1694 0.1636
\end{verbatim}

Bemerkung: Ein erneuter Aufruf liefert natürlich wieder andere relative Häufigkeiten.

Auch beim Umfang 100000 geht übrigens es sehr schnell!

Aufgabe:

Untersuchen Sie die gleiche Frage für das zweite Beispiel des Wahrnehmungsexperiments!

\hypertarget{eine-simulation-zum-vertrauensintervall}{%
\subsection{Eine Simulation zum Vertrauensintervall}\label{eine-simulation-zum-vertrauensintervall}}

Einführungsfolie 67: Wie wahrscheinlich ist es beim Würfeln, dass das t-Vertrauensintervall zum Niveau .95 auf der Basis von Stichproben vom Umfang 60 den Erwartungswert 3.5 enthält? Die Wahrscheinlichkeit soll durch Simulationen abgeschätzt werden (da die Würfelergebnisse nicht normalverteilt sind, ist eine der Voraussetzungen für das t-Vertrauensintervall eigentlich nicht gegeben).

Vielleicht ist es praktisch, die Prüfung, ob eine Zahl in einem Intervall liegt, auszulagern:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{istin }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, i, }\AttributeTok{gr =}\NormalTok{ F)\{       }\CommentTok{\# (1)}
\NormalTok{  ug }\OtherTok{\textless{}{-}}\NormalTok{ i[}\DecValTok{1}\NormalTok{]                           }\CommentTok{\# (2)}
\NormalTok{  og }\OtherTok{\textless{}{-}}\NormalTok{ i[}\DecValTok{2}\NormalTok{]}
\NormalTok{  wug }\OtherTok{\textless{}{-}} \ControlFlowTok{if}\NormalTok{(gr) x }\SpecialCharTok{\textgreater{}=}\NormalTok{ ug }\ControlFlowTok{else}\NormalTok{ x }\SpecialCharTok{\textgreater{}}\NormalTok{ ug    }\CommentTok{\# (3)}
\NormalTok{  wog }\OtherTok{\textless{}{-}} \ControlFlowTok{if}\NormalTok{(gr) x }\SpecialCharTok{\textless{}=}\NormalTok{ og }\ControlFlowTok{else}\NormalTok{ x }\SpecialCharTok{\textless{}}\NormalTok{ og}
  \FunctionTok{return}\NormalTok{(wug }\SpecialCharTok{\&}\NormalTok{ wog)                    }\CommentTok{\# (4)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen;

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  x ist ein Wert, i ein Intervall, gegeben durch einen Vektor aus unterer und oberer Grenze. Es soll die Frage beantwortet werden, ob x in dem Intervall liegt. Der Parameter gr gibt an, ob die Grenzen zum Intervall dazugehören (T) oder nicht.
\item
  Die untere Intervallgrenze, nächste Zeile die obere
\item
  Die Variable wug enthält einen logischen Wert: T, wenn x größer bzw. größer/gleich der unteren Intervallgrenze ist, F sonst. Beachte: x\textgreater=ug ist ein logischer Wert, T, wenn x\textgreater= ug richtig ist, F sonst.
\item
  Zurückgegeben wird die Und-Verknüpfung von wug und wog, die nur dann T ist, wenn wug und wog beide T sind, sonst F.
\end{enumerate}

Nun ist die Simulation einfach, der Umfang der Einzelstichproben und der Umfang der Simulation sind wählbar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w\_vi\_simul }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, N, }\AttributeTok{p =}\NormalTok{ .}\DecValTok{95}\NormalTok{)\{    }\CommentTok{\# (1)}
\NormalTok{  z }\OtherTok{\textless{}{-}} \DecValTok{0}                                  \CommentTok{\# (2)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(N))\{                       }\CommentTok{\# (3)}
\NormalTok{    s }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{),n,}\AttributeTok{replace =}\NormalTok{ T)     }\CommentTok{\# (4)}
\NormalTok{    vi }\OtherTok{\textless{}{-}} \FunctionTok{my\_t\_vi}\NormalTok{(s,p)                    }\CommentTok{\# (5)}
    \ControlFlowTok{if}\NormalTok{(}\FunctionTok{istin}\NormalTok{(}\FloatTok{3.5}\NormalTok{,vi)) z }\OtherTok{=}\NormalTok{ z }\SpecialCharTok{+} \DecValTok{1}           \CommentTok{\# (5)}
\NormalTok{  \}}
  \FunctionTok{return}\NormalTok{(z}\SpecialCharTok{/}\NormalTok{N)                             }\CommentTok{\# (7)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Der Name soll für Würfel-Vertrauensintervall-Simulation stehen, n ist der Stichprobenumfang der Einzelstichproben, N ist der Umfang der Simulation, p ist das Niveau für das Vertrauensintervall.
\item
  Wieder ein Zähler z.
\item
  Die Schleife für die Gesamtsimulation vom Umfang N.
\item
  Es wird jeweils eine Zufallsstichprobe s von n Würfelergebnissen erzeugt.
\item
  Das t-Vertrauensintervall vi zum Niveau p wird gebildet.
\item
  Wenn der (hier bekannte) Erwartungswert von 3.5 in dem Intervall liegt, wird z um 1 vergrößert.
\item
  Ausgegeben wird die relative Häufigkeit der Fälle, in denen das Vertrauensintervall den Erwartungswert 3.5 enthält.
\end{enumerate}

Zahlen wie auf Folie 67 erhält man jetzt mit w\_vi\_simul(60,10000). Wieder kommt das Ergebnis ziemlich schnell.

Wenn Sie die Funktion mit denselben Argumenten zweimal aufrufen, werden Sie praktisch immer unterschiedliche Ergebnisse bekommen, da ja jedes Mal neue Zufallsstichproben gezogen werden.

Um schnell mehrere Ergebnisse zu erhalten, können Sie den Befehl unten in der Konsole eingeben; nachdem das Ergebnis bestimmt ist, holen Sie den Befehl mit Pfeiltaste nach oben wieder zurück und können ihn dann gleich noch einmal ausführen. Auch im Source-Fenster gibt es eine solche Möglichkeit: Ctrl-Alt-P führt den letzten Befehl noch einmal aus. Die Shortcuts finden Sie übrigens im Menü unter Help oder direkt mit Alt-Shift-K.

\hypertarget{simulationen-zum-wahrnehmungsexperiment}{%
\subsection{Simulationen zum Wahrnehmungsexperiment}\label{simulationen-zum-wahrnehmungsexperiment}}

Im ersten Semester wurden auch Simulationen zum Verhalten des t-Tests bei dem fiktiven Wahrnehmungsexperiment gemacht (Folie 78, dann ab Folie 82). Hier waren die Variablen (Fehlerzahl) diskret, daher ist es fraglich, ob man den t-Test dennoch verwenden kann (es geht also um die Robustheit).

Hier zunächst eine neue Version des t-Tests:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_t\_test1 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x1,x2,n1,n2,df,vf)\{      }\CommentTok{\# (1)}
\NormalTok{  m1 }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x1)}\SpecialCharTok{/}\NormalTok{n1                              }\CommentTok{\# (2)         }
\NormalTok{  m2 }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(x2)}\SpecialCharTok{/}\NormalTok{n2}
\NormalTok{  sqa1 }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{((x1}\SpecialCharTok{{-}}\NormalTok{m1)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)                        }\CommentTok{\# (3)           }
\NormalTok{  sqa2 }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{((x2}\SpecialCharTok{{-}}\NormalTok{m2)}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)                 }
\NormalTok{  sq }\OtherTok{\textless{}{-}}\NormalTok{ (sqa1 }\SpecialCharTok{+}\NormalTok{ sqa2)}\SpecialCharTok{/}\NormalTok{df                        }\CommentTok{\# (4)}
\NormalTok{  nenner }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(vf}\SpecialCharTok{*}\NormalTok{sq)         }
\NormalTok{  t }\OtherTok{\textless{}{-}}\NormalTok{ (m1}\SpecialCharTok{{-}}\NormalTok{m2)}\SpecialCharTok{/}\NormalTok{nenner}
  \FunctionTok{return}\NormalTok{(t)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Die Funktion ist von früher einigermaßen bekannt, es gibt aber Veränderungen und es fehlen Teile.

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Die Argumente x1 und x2 stehen für die beiden Stichproben, als weitere Argumente werden die Stichprobengrößen n1 und n2, die Anzahl der Freiheitsgrade df und der Vorfaktor vf des Nenners übergeben. Diese Zahlen müssen also außerhalb der Funktion bestimmt werden. Das scheint erstmal nicht besonders sinnvoll zu sein. In der Simulation wird diese Funktion jedoch immer wieder aufgerufen, wobei die vier zusätzlichen Argumente immer gleich groß sind. Wenn diese Zahlen immer wieder neu bestimmt werden müssten, würde das Zeit kosten, daher sollen sie außerhalb der Funktion nur einmal berechnet und dann übergeben werden. Die Zeitersparnis ist in diesem Fall allerdings minimal, hier soll nur auf die Möglichkeit hingewiesen werden, dass man bei komplizierteren zeitintensiven Rechnungen, die immer wieder auftreten, auf diese Art manchmal merklich Zeit sparen kann.
\item
  Die Mittelwerte werden jetzt in der Funktion berechnet, n1 wird als Argument übergeben.
\item
  Auch die Summen der quadrierten Abweichungen vom Mittelwert werden in der Funktion berechnet, nicht aber die Varianzen. Die Varianzen werden ja eigentlich nicht gebraucht, da im Zähler von \(s^2\) gerade die Summe dieser beiden Summen steht, wie man sich leicht überzeugt. Man erspart sich so die nutzlose Division und anschließende Multiplikation mit der jeweiligen Stichprobengröße (auch hier ist der Zeitgewinn minimal, es soll aber auf die Möglichkeit von Zeitersparnis in komplizierteren Situationen aufmerksam gemacht werden).
\item
  Auch die Zahl df der in der Simulation immer gleichen Freiheitsgrade und der einheitliche Vorfaktor vf im Nenner (nächste Zeile) müssen außerhalb bestimmt und als Argumente übergeben werden.
\end{enumerate}

Aufgabe: Überzeugen Sie sich an einem Beispiel, dass der t-Wert korrekt bestimmt wird; Sie müssen dann vorher die Variablen n1, n2, df und vf korrekt belegen.

Der Übersichtlichkeit halber kann man auch die Bildung der Zufallsstichproben zu einer eigenen Funktion machen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z\_stpr\_w }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, w)\{  }
  \FunctionTok{sample}\NormalTok{(}\DecValTok{0}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, n, }\AttributeTok{replace =}\NormalTok{ T, }\AttributeTok{prob=}\NormalTok{w)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkung: Da die Fehlerzahl immer eine Zahl zwischen 0 und 5 ist, kann dies Argument weggelassen werden. Als Argumente bleiben die Stichprobengröße n und der Vektor w der Wahrscheinlichkeiten dieser Zahlen. z\_stpr\_w soll Zufallsstichprobe Wahrnehmung abkürzen.

Nun die Funktion, die mit Hilfe einer Simulation die Wahrscheinlichkeit eines signifikanten Ergebnisses zu schätzen versucht:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{we\_t\_simul }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(N,n1,w1,n2,w2,}\AttributeTok{a =}\NormalTok{ .}\DecValTok{05}\NormalTok{)\{           }\CommentTok{\# (1)}
\NormalTok{  df }\OtherTok{\textless{}{-}}\NormalTok{ n1 }\SpecialCharTok{+}\NormalTok{ n2 }\SpecialCharTok{{-}} \DecValTok{2}                                      \CommentTok{\# (2)}
\NormalTok{  vf }\OtherTok{\textless{}{-}}\NormalTok{ (n1 }\SpecialCharTok{+}\NormalTok{ n2)}\SpecialCharTok{/}\NormalTok{(n1 }\SpecialCharTok{*}\NormalTok{ n2)}
\NormalTok{  kw }\OtherTok{\textless{}{-}} \FunctionTok{qt}\NormalTok{(a,df)                                         }\CommentTok{\# (3)}
\NormalTok{  z }\OtherTok{\textless{}{-}} \DecValTok{0}                                                 \CommentTok{\# (4)}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(N))\{                                      }\CommentTok{\# (5)}
\NormalTok{    x1 }\OtherTok{\textless{}{-}} \FunctionTok{z\_stpr\_w}\NormalTok{(n1,w1)                                }\CommentTok{\# (6)}
\NormalTok{    x2 }\OtherTok{\textless{}{-}} \FunctionTok{z\_stpr\_w}\NormalTok{(n2,w2)}
    \ControlFlowTok{if}\NormalTok{(}\FunctionTok{my\_t\_test1}\NormalTok{(x1,x2,n1,n2,df,vf) }\SpecialCharTok{\textless{}=}\NormalTok{ kw) z }\OtherTok{\textless{}{-}}\NormalTok{ z }\SpecialCharTok{+} \DecValTok{1}   \CommentTok{\# (7)}
\NormalTok{  \}}
\NormalTok{  z}\SpecialCharTok{/}\NormalTok{N                                                    }\CommentTok{\# (8)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Anmerkungen:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\item
  Der Funktionsname steht für Wahrnehmungsexperiment-t-Test-Simulation. Die Argumente sind: Die Zahl N der Simulationen, der Umfang n1 der ersten Stichprobe (auf den Folien die Kontrollgruppe), die Verteilung w1 der möglichen Fehlerzahlen in der Kontrollgruppe, entsprechend n2 und w2 für die zweite Stichprobe (die Alkoholgruppe), außerdem das Signifikanzniveau a, standardmäßig .05.
\item
  Die Zahl der Freiheitsgrade wird ein für alle Mal bestimmt, ebenso in der nächsten Zeile der Vorfaktor. Das bringt hier zwar keinen merklichen Vorteil, ähnliches Vorgehen in anderen Zusammenhängen manchmal schon.
\item
  Der kritische Wert kw. Achtung: Im Gegensatz zu den Folien wird hier linksseitig getestet, da die Konventionen hier anders sind (Mittelwertdifferenz M1-M2 und nicht M2-M1).
\item
  Es wird wieder ein Zähler eingerichtet und auf 0 gesetzt.
\item
  Die Schleife der Simulation.
\item
  Die erste Stichprobe (Kontrollgruppe), nächste Zeile die zweite.
\item
  Der t-Test, wenn er linksseitig signifikant wird, wird der Zähler erhöht.
\item
  Ausgabe der relativen Häufigkeit signifikanter Ergebnisse.
\end{enumerate}

Es folgen einige Verteilungen aus den Folien:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(.}\DecValTok{1}\NormalTok{,.}\DecValTok{15}\NormalTok{,.}\DecValTok{35}\NormalTok{,.}\DecValTok{25}\NormalTok{,.}\DecValTok{1}\NormalTok{,.}\DecValTok{05}\NormalTok{)}
\NormalTok{w2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(.}\DecValTok{05}\NormalTok{,.}\DecValTok{1}\NormalTok{,.}\DecValTok{25}\NormalTok{,.}\DecValTok{3}\NormalTok{,.}\DecValTok{2}\NormalTok{,.}\DecValTok{1}\NormalTok{)}
\NormalTok{w2a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(.}\DecValTok{05}\NormalTok{,.}\DecValTok{05}\NormalTok{,.}\DecValTok{1}\NormalTok{,.}\DecValTok{15}\NormalTok{,.}\DecValTok{25}\NormalTok{,.}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Simulation Folie 79:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{we\_t\_simul}\NormalTok{(}\DecValTok{10000}\NormalTok{,}\DecValTok{20}\NormalTok{,w1,}\DecValTok{20}\NormalTok{,w1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.0484
\end{verbatim}

Untersuchung von \(\beta\) (Folie 82):

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{{-}}\FunctionTok{we\_t\_simul}\NormalTok{(}\DecValTok{10000}\NormalTok{,}\DecValTok{20}\NormalTok{,w1,}\DecValTok{20}\NormalTok{,w2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6247
\end{verbatim}

Hier geht es um die nichtsignifikanten Ergebnisse, daher ``1-\ldots{}''

Erstes Beispiel Folie 83:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{{-}}\FunctionTok{we\_t\_simul}\NormalTok{(}\DecValTok{10000}\NormalTok{,}\DecValTok{20}\NormalTok{,w1,}\DecValTok{20}\NormalTok{,w2,.}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.4749
\end{verbatim}

Aufgabe: Überzeugen Sie sich, dass die weiteren Ergebnisse auf den Folien zur Untersuchung von \(\beta\) einigermaßen mit den Ergebnissen dieses Programms übereinstimmen!

Interessant ist dann noch das Beispiel auf Folie 92, hier zunächst die Verteilungen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w1x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,.}\DecValTok{5}\NormalTok{,.}\DecValTok{5}\NormalTok{,}\DecValTok{0}\NormalTok{,.}\DecValTok{0}\NormalTok{)}
\NormalTok{w2x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(.}\DecValTok{5}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,.}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Das Ergebnis bekommen Sie mit

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{we\_t\_simul}\NormalTok{(}\DecValTok{10000}\NormalTok{,}\DecValTok{20}\NormalTok{,w1x,}\DecValTok{5}\NormalTok{,w2x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1872
\end{verbatim}

  \bibliography{book.bib}

\end{document}
